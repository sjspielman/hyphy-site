{
    "docs": [
        {
            "location": "/", 
            "text": "Hypothesis Testing using Phylogenies\n\n        \nAn open-source software package\n\n            \nfor comparative sequence analysis\n\n            \nusing stochastic evolutionary models\n\n    \nDownload\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n\n  \n\n  \n\n    \nHyPhy News", 
            "title": "Home"
        }, 
        {
            "location": "/about/", 
            "text": "Overview\n#\n\n\nHyPhy (\nHy\npothesis Testing using \nPhy\nlogenies) is an open-source software package for the analysis of genetic sequences (in particular the inference of natural selection) using techniques in phylogenetics, molecular evolution, and machine learning. It features a rich scripting language for limitless customization of analyses. Additionally, HyPhy features support for parallel computing environments (via message passing interface). HyPhy has over 10000 registered users and has been cited in over 1800 peer-reviewed publications (\nGoogle Scholar\n). \n\n\nBrief history\n#\n\n\nHyPhy grew out of the collaboration between \nSpencer Muse\n and \nSergei Kosakovsky Pond\n that commenced in 1997 and continues to this day, with many additional collaborators, including \nArt Poon\n, \nSimon Frost\n, \nSteven Weaver\n, \nStephanie Spielman\n, \nLance Hepler\n, \nMartin Smith\n, \nKonrad Scheffler\n, \nWayne Delport\n, \nBen Murrell\n, and \nJoel Wertheim\n. HyPhy was originally released in 2000, is currently at version 2.3, and is presently undergoing a major rewrite, with version v3.0 planned for release in 2018. \n\n\nDesign philosophy\n#\n\n\nHyPhy was designed to allow the specification and fitting of a broad class of continuous-time discrete-space Markov models of sequence evolution. To implement these models, HyPhy provides its own scripting language - \nHBL\n, or \nHyPhy Batch Language\n (see \nan example\n), which can be used to develop custom analyses or modify existing ones. Importantly, it is not necessary to learn (or even be aware of) HBL in order to use HyPhy, as most common models and analyses have been implemented for user convenience. Once a model is defined, it can be fitted to data (using a fixed topology tree), its parameters can be constrained in user-defined ways to test various hypotheses (e.g. is rate1 \n rate2), and simulate data from. HyPhy primarily implements \nmaximum likelihood\n methods, but it can also be used to perform some forms of Bayesian inference (e.g. \nFUBAR\n), fit Bayesian graphical models to data, run genetic algorithms to perform complex model selection.\n\n\nFeatures\n#\n\n\n\n\nSupport for arbitrary sequence data, including nucleotide, amino-acid, codon, binary, count (microsattelite) data, including multiple partitions mixing differen data types. \n\n\nComplex models of rate variation, including site-to-site, branch-to-branch, hidden markov model (autocorrelated rates), between/within partitions, and co-varion type models.\n\n\nFast numerical fitting routines, supporting parallel and distributed execution.\n\n\nA broad collection of pre-defined evolutionary models. \n\n\nThe ability to specify flexible constraints on model parameters and estimate confidence intervals on MLEs.\n\n\nAncestral sequence reconstruction and sampling. \n\n\nSimulate data from any model that can be defined and fitted in the language.\n\n\nApply unique (for this domain) machine learning methods to discover patterns in the data, e.g. genetic algorithms, stochastic context free grammars, Bayesian graphical models.\n\n\nScript analyses completely in HBL including flow control, I/O, parallelization, etc.\n\n\n(v2.3) Modern web-applications for interactive result visualization.\n\n\n\n\nExample HBL Script\n#\n\n\n/* \n\n\n   This is an example HYPHY Batch File.\n\n\n   It reads in a MEGA format nucleotide dataset from data/hiv.nuc.\n\n\n   and fits the F81 model using the tree inclded in the file using maximum likelihood.\n\n\n   Output is printed out as a Newick Style tree with branch lengths\n\n\n   representing the number of expected substitutions per branch.\n\n\n*/\n\n\n\n// 1. Read in the data and store the result in a DataSet variable\n\n\n\nDataSet\n         \nnucleotideSequences\n \n=\n \nReadDataFile\n \n(\ndata/hiv.nuc\n);\n\n\n\n// 2. Filter the data, specifying that all of the data is to be used\n\n\n//  and that it is to be treated as nucleotides.*/\n\n\n\nDataSetFilter\n   \nfilteredData\n \n=\n \nCreateFilter\n \n(\nnucleotideSequences\n,\n1\n);\n\n\n\n// Collect observed nucleotide frequencies from the filtered data. observedFreqs will\n\n\n// store receieve the vector of frequencies. \n\n\n\nHarvestFrequencies\n \n(\nobservedFreqs\n,\n \nfilteredData\n,\n \n1\n,\n \n1\n,\n \n1\n);\n\n\n\n// Define the F81 substitution matrix. \n*\n is defined to be -(sum of off-diag row \n\n\n// elements); mu is the rate*time parameter \n\n\n\nF81RateMatrix\n \n=\n \n        \n{{\n*\n,\nmu\n,\nmu\n,\nmu\n}\n\n         \n{\nmu\n,\n*\n,\nmu\n,\nmu\n}\n\n         \n{\nmu\n,\nmu\n,\n*\n,\nmu\n}\n\n         \n{\nmu\n,\nmu\n,\nmu\n,\n*\n}};\n\n\n\n//  Define the F81 models, by combining the substitution matrix with the vector of observed (equilibrium) frequencies.\n\n\n\nModel\n   \nF81\n \n=\n \n(\nF81RateMatrix\n,\n \nobservedFreqs\n);\n\n\n\n// Now we can define the tree variable, using the tree string read from the data file, \n\n\n// and, by default, assigning the last defined model (F81) to all tree branches.\n\n\n\nTree\n    \ngivenTree\n \n=\n \nDATAFILE_TREE\n;\n\n\n\n// Since all the likelihood function ingredients (data, tree, equilibrium frequencies)\n\n\n// have been defined we are ready to construct the likelihood function.\n\n\n\nLikelihoodFunction\n  \nLF\n \n=\n \n(\nfilteredData\n,\n \ngivenTree\n);\n\n\n\n// Maximize the likelihood function, storing parameter values in the matrix paramValues \n\n\n\nOptimize\n \n(\nparamValues\n,\n \nLF\n);\n\n\n\n// Print the tree with optimal branch lengths to the console. \n\n\n\nfprintf\n  \n(\nstdout\n,\n \nLF\n);", 
            "title": "About"
        }, 
        {
            "location": "/about/#overview", 
            "text": "HyPhy ( Hy pothesis Testing using  Phy logenies) is an open-source software package for the analysis of genetic sequences (in particular the inference of natural selection) using techniques in phylogenetics, molecular evolution, and machine learning. It features a rich scripting language for limitless customization of analyses. Additionally, HyPhy features support for parallel computing environments (via message passing interface). HyPhy has over 10000 registered users and has been cited in over 1800 peer-reviewed publications ( Google Scholar ).", 
            "title": "Overview"
        }, 
        {
            "location": "/about/#brief-history", 
            "text": "HyPhy grew out of the collaboration between  Spencer Muse  and  Sergei Kosakovsky Pond  that commenced in 1997 and continues to this day, with many additional collaborators, including  Art Poon ,  Simon Frost ,  Steven Weaver ,  Stephanie Spielman ,  Lance Hepler ,  Martin Smith ,  Konrad Scheffler ,  Wayne Delport ,  Ben Murrell , and  Joel Wertheim . HyPhy was originally released in 2000, is currently at version 2.3, and is presently undergoing a major rewrite, with version v3.0 planned for release in 2018.", 
            "title": "Brief history"
        }, 
        {
            "location": "/about/#design-philosophy", 
            "text": "HyPhy was designed to allow the specification and fitting of a broad class of continuous-time discrete-space Markov models of sequence evolution. To implement these models, HyPhy provides its own scripting language -  HBL , or  HyPhy Batch Language  (see  an example ), which can be used to develop custom analyses or modify existing ones. Importantly, it is not necessary to learn (or even be aware of) HBL in order to use HyPhy, as most common models and analyses have been implemented for user convenience. Once a model is defined, it can be fitted to data (using a fixed topology tree), its parameters can be constrained in user-defined ways to test various hypotheses (e.g. is rate1   rate2), and simulate data from. HyPhy primarily implements  maximum likelihood  methods, but it can also be used to perform some forms of Bayesian inference (e.g.  FUBAR ), fit Bayesian graphical models to data, run genetic algorithms to perform complex model selection.", 
            "title": "Design philosophy"
        }, 
        {
            "location": "/about/#features", 
            "text": "Support for arbitrary sequence data, including nucleotide, amino-acid, codon, binary, count (microsattelite) data, including multiple partitions mixing differen data types.   Complex models of rate variation, including site-to-site, branch-to-branch, hidden markov model (autocorrelated rates), between/within partitions, and co-varion type models.  Fast numerical fitting routines, supporting parallel and distributed execution.  A broad collection of pre-defined evolutionary models.   The ability to specify flexible constraints on model parameters and estimate confidence intervals on MLEs.  Ancestral sequence reconstruction and sampling.   Simulate data from any model that can be defined and fitted in the language.  Apply unique (for this domain) machine learning methods to discover patterns in the data, e.g. genetic algorithms, stochastic context free grammars, Bayesian graphical models.  Script analyses completely in HBL including flow control, I/O, parallelization, etc.  (v2.3) Modern web-applications for interactive result visualization.", 
            "title": "Features"
        }, 
        {
            "location": "/about/#example-hbl-script", 
            "text": "/*      This is an example HYPHY Batch File.     It reads in a MEGA format nucleotide dataset from data/hiv.nuc.     and fits the F81 model using the tree inclded in the file using maximum likelihood.     Output is printed out as a Newick Style tree with branch lengths     representing the number of expected substitutions per branch.  */  // 1. Read in the data and store the result in a DataSet variable  DataSet           nucleotideSequences   =   ReadDataFile   ( data/hiv.nuc );  // 2. Filter the data, specifying that all of the data is to be used  //  and that it is to be treated as nucleotides.*/  DataSetFilter     filteredData   =   CreateFilter   ( nucleotideSequences , 1 );  // Collect observed nucleotide frequencies from the filtered data. observedFreqs will  // store receieve the vector of frequencies.   HarvestFrequencies   ( observedFreqs ,   filteredData ,   1 ,   1 ,   1 );  // Define the F81 substitution matrix.  *  is defined to be -(sum of off-diag row   // elements); mu is the rate*time parameter   F81RateMatrix   =  \n         {{ * , mu , mu , mu } \n          { mu , * , mu , mu } \n          { mu , mu , * , mu } \n          { mu , mu , mu , * }};  //  Define the F81 models, by combining the substitution matrix with the vector of observed (equilibrium) frequencies.  Model     F81   =   ( F81RateMatrix ,   observedFreqs );  // Now we can define the tree variable, using the tree string read from the data file,   // and, by default, assigning the last defined model (F81) to all tree branches.  Tree      givenTree   =   DATAFILE_TREE ;  // Since all the likelihood function ingredients (data, tree, equilibrium frequencies)  // have been defined we are ready to construct the likelihood function.  LikelihoodFunction    LF   =   ( filteredData ,   givenTree );  // Maximize the likelihood function, storing parameter values in the matrix paramValues   Optimize   ( paramValues ,   LF );  // Print the tree with optimal branch lengths to the console.   fprintf    ( stdout ,   LF );", 
            "title": "Example HBL Script"
        }, 
        {
            "location": "/register/", 
            "text": "input[type=\"radio\"]{\n            -webkit-appearance: radio;\n    }\n    label.title{\n        font-weight: bold;\n    }\n\n\n\n\n\n\n        \n\n            If you have already registered, or wish to postpone or skip registration, you may proceed directly\n            to the \ndownload\n page.\n        \n\n\n        \n\n            \nPlease take your time to fill out all the relevant information in the form below.\n            If you register, we will be able to notify you of code updates and other news. Additionally, we would \n            like to know how people use HYPHY, so we can add and improve the features of the package.\n\n        \n\n\n\n\n        \n\n      \nemail address\n\n      \n\n        \n\n\n        \n\n            \nInstitution\n\n            \n\n        \n\n\n        \n\n\n      \nWhat do you mainly use HyPhy for?\n\n\n            \n\n                \n\n                Selection Analysis\n            \n\n\n            \n\n                \n\n                Model Development\n            \n\n\n            \n\n                \n\n                Other\n            \n\n\n    \n\n\n        \n\n            \nHave you cited HyPhy results in a publication?\n\n\n            \n\n                \n\n                Yes\n            \n\n\n            \n\n                \n\n                No\n            \n\n\n        \n\n\n        \n\n            \nHow did you first find out about HyPhy?\n\n            \n\n                \n\n                \nColleague\n\n                \nMailing List\n\n                \nSoftware Listing Page\n\n                \nSearch Engine (i.e. Google)\n\n                \nPublication\n\n                \nConference/Seminar\n\n                \nOther\n\n            \n       \n        \n\n\n    \n\n    \nSubmit", 
            "title": "Download"
        }, 
        {
            "location": "/download/", 
            "text": "Download and Install GUI\n#\n\n\nTo download the Desktop/GUI version of HyPhy, follow instructions on this \ndownload page\n. \n\n\n\n\nNOTE\n: The HyPhy GUI is no longer maintained and will be replaced in the near future with a JavaScript front-end. For those interested in a GUI experience, we recommend using HyPhy either via \nDatamonkey\n (for newer methods see \nthe development version of Datamonkey\n) or from the command line on your local computer/server. \n\n\n\n\n\n\n\nDownload and Install from source\n#\n\n\n\n\nHyPhy depends on \nCMake version 3 or later\n for its build system. Before installing HyPhy, please make sure that an appropriate version of \nCMake\n has been installed. Some HyPhy configurations also depends on other development libraries like \nlibcurl\n and  \nlibpthread\n. \nLibcurl\n requires development libraries such as  \ncrypto++\n and  \nopenssl\n (or  \ngnutls\n depending on your configuration). On Ubuntu these are  \nlibcurl-dev\n,  \nlibcrypto++-dev\n and  \nlibssl-dev\n.\n\n\n\n\nYou can obtain HyPhy source in two ways:\n\n\n\n\nDownload a the latest HyPhy release from \nthe HyPhy github repository\n.\n\n\nDownload the master branch of HyPhy by cloning the repository by entering this command into a terminal session:\n\n\n\n\ngit clone https://github.com/veg/hyphy.git\n\n\n\n\n\nOnce you have downloaded HyPhy, follow these \ninstallation instructions\n.", 
            "title": "_Real_Download"
        }, 
        {
            "location": "/download/#download-and-install-gui", 
            "text": "To download the Desktop/GUI version of HyPhy, follow instructions on this  download page .    NOTE : The HyPhy GUI is no longer maintained and will be replaced in the near future with a JavaScript front-end. For those interested in a GUI experience, we recommend using HyPhy either via  Datamonkey  (for newer methods see  the development version of Datamonkey ) or from the command line on your local computer/server.", 
            "title": "Download and Install GUI"
        }, 
        {
            "location": "/download/#download-and-install-from-source", 
            "text": "HyPhy depends on  CMake version 3 or later  for its build system. Before installing HyPhy, please make sure that an appropriate version of  CMake  has been installed. Some HyPhy configurations also depends on other development libraries like  libcurl  and   libpthread .  Libcurl  requires development libraries such as   crypto++  and   openssl  (or   gnutls  depending on your configuration). On Ubuntu these are   libcurl-dev ,   libcrypto++-dev  and   libssl-dev .   You can obtain HyPhy source in two ways:   Download a the latest HyPhy release from  the HyPhy github repository .  Download the master branch of HyPhy by cloning the repository by entering this command into a terminal session:   git clone https://github.com/veg/hyphy.git  Once you have downloaded HyPhy, follow these  installation instructions .", 
            "title": "Download and Install from source"
        }, 
        {
            "location": "/installation/", 
            "text": "Installation\n#\n\n\n\n\nBefore continuing, please \nregister and download HyPhy\n.\n\n\n\n\nOnce downloaded, install HyPhy as follows:\n\n\n\n\n\n\nNavigate to the newly downloaded/cloned HyPhy directory\n\n\ncd hyphy\n\n\n\n\n\n\n\n\n\nConfigure HyPhy using \nCMake\n\n\ncmake .\n\n\n\n\n\n\n\n\n\nBy default, HyPhy will be installed into \n/usr/local/\n, but it can be installed on any location of your system by specifying a custom installation path:\n\n\ncmake -DINSTALL_PREFIX=/location/of/choice .\n\n\n\n\n\n\n\n\n\nIf you prefer to use other build systems \nsupported by CMake\n, such as \nXCode\n, configure HyPhy using the generator (\n-G\n) switch:\n\n\ncmake -G Xcode .\n\n\n\n\n\n\n\n\n\nIf would like to specify a particular C/C++ compiler (please note that it must support the C++-14 language standard) for your HyPhy build, use this command:\n\n\ncmake . -DCMAKE_CXX_COMPILER=/path/to/C++-compiler -DCMAKE_C_COMPILER=/path/to/C-compiler\n\n\n\n\n\n\n\n\n\n\n\n\n\nIf you are building HyPhy under MacOS X, you can specify which version of SDK to use, for example:\n\n\n    cmake -DCMAKE_OSX_SYSROOT=/Developer/SDKs/MacOSX10.9.sdk/ .\n\n\n\n\n\n\n\n\n\nBuild HyPhy by running \nmake\n with one of the following build targets given below. Note that including the \n-j\n flag for make (i.e. \nmake -j \ntarget\n) will dramatically speed this step up by taking advantage of multiple processors.\n\n\n## make the HYPHYMP executable:\nmake MP\n## Faster:\nmake -j MP\n\n## make the HYPHYMPI executable:\nmake MPI\n\n\n\n\n\n\n\n\n\nMP\n - build a HyPhy executable (\nHYPHYMP\n) using \nOpenMP\n to support symmetric multiprocessing. If \nOpenMP\n is not installed or not supported by the compiler (e.g. LLVM), the compiled executable will not support multi-threading. You can confirm  case by examining the output from running \ncmake\n. If \nopenMP\n is installed, you should see something similar to the following in the output:\n\n\n-- Performing Test OpenMP_FLAG_DETECTED\n-- Performing Test OpenMP_FLAG_DETECTED - Success\n-- Try OpenMP CXX flag = [-fopenmp]\n-- Performing Test OpenMP_FLAG_DETECTED\n-- Performing Test OpenMP_FLAG_DETECTED - Success\n-- Found OpenMP: -fopenmp\n\n\n\n\n\n\n\n\n\nMPI\n - build a HyPhy executable (\nHYPHYMPI\n) using the message passing interface \nMPI\n to support parallel execution on distributed systems (clusters). An MPI library (e.g., OpenMPI) must be installed and available in your path. You can check if this is the case by examining the output from running \ncmake\n. If \nopenMPI\n is installed, you should see something similar to the following in the output:\n\n\n    \n--\n \nFound\n \nMPI_C\n:\n \n/\nopt\n/\nscyld\n/\nopenmpi\n/\n1\n.\n6\n.\n3\n/\ngnu\n/\nlib\n/\nlibmpi\n.\nso\n;/\nusr\n/\nlib64\n/\nlibibverbs\n.\nso\n;/\nusr\n/\nlib64\n/\nlibdat\n.\nso\n;/\nusr\n/\nlib64\n/\nlibrt\n.\nso\n;/\nusr\n/\nlib64\n/\nlibnsl\n.\nso\n;/\nusr\n/\nlib64\n/\nlibutil\n.\nso\n;/\nusr\n/\nlib64\n/\nlibm\n.\nso\n;/\nusr\n/\nlib64\n/\nlibtorque\n.\nso\n;/\nusr\n/\nlib64\n/\nlibm\n.\nso\n;/\nusr\n/\nlib64\n/\nlibnuma\n.\nso\n;/\nusr\n/\nlib64\n/\nlibrt\n.\nso\n;/\nusr\n/\nlib64\n/\nlibnsl\n.\nso\n;/\nusr\n/\nlib64\n/\nlibutil\n.\nso\n;/\nusr\n/\nlib64\n/\nlibm\n.\nso\n\n\n    \n--\n \nFound\n \nMPI_CXX\n:\n \n/\nopt\n/\nscyld\n/\nopenmpi\n/\n1\n.\n6\n.\n3\n/\ngnu\n/\nlib\n/\nlibmpi_cxx\n.\nso\n;/\nopt\n/\nscyld\n/\nopenmpi\n/\n1\n.\n6\n.\n3\n/\ngnu\n/\nlib\n/\nlibmpi\n.\nso\n;/\nusr\n/\nlib64\n/\nlibibverbs\n.\nso\n;/\nusr\n/\nlib64\n/\nlibdat\n.\nso\n;/\nusr\n/\nlib64\n/\nlibrt\n.\nso\n;/\nusr\n/\nlib64\n/\nlibnsl\n.\nso\n;/\nusr\n/\nlib64\n/\nlibutil\n.\nso\n;/\nusr\n/\nlib64\n/\nlibm\n.\nso\n;/\nusr\n/\nlib64\n/\nlibtorque\n.\nso\n;/\nusr\n/\nlib64\n/\nlibm\n.\nso\n;/\nusr\n/\nlib64\n/\nlibnuma\n.\nso\n;/\nusr\n/\nlib64\n/\nlibrt\n.\nso\n;/\nusr\n/\nlib64\n/\nlibnsl\n.\nso\n;/\nusr\n/\nlib64\n/\nlibutil\n.\nso\n;/\nusr\n/\nlib64\n/\nlibm\n.\nso\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, install HyPhy on your system with the command\n\n\nmake install\n\n\n\n\n\nHyPhy will install either in its default location \n/usr/local/\n, or in any custom  \n/location/of/choice/\n provided when configuring \nCMake\n.\n\n\n\n\nHYPHYMP(I)\n will be installed at  \n/location/of/choice/bin\n\n\nlibhyphy_mp.(so/dylib/dll)\n will be installed at \n/location/of/choice/lib\n\n\nHyPhy's standard library of scripts/batchfiles will go into \n/location/of/choice/lib/hyphy", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "Before continuing, please  register and download HyPhy .   Once downloaded, install HyPhy as follows:    Navigate to the newly downloaded/cloned HyPhy directory  cd hyphy    Configure HyPhy using  CMake  cmake .    By default, HyPhy will be installed into  /usr/local/ , but it can be installed on any location of your system by specifying a custom installation path:  cmake -DINSTALL_PREFIX=/location/of/choice .    If you prefer to use other build systems  supported by CMake , such as  XCode , configure HyPhy using the generator ( -G ) switch:  cmake -G Xcode .    If would like to specify a particular C/C++ compiler (please note that it must support the C++-14 language standard) for your HyPhy build, use this command:  cmake . -DCMAKE_CXX_COMPILER=/path/to/C++-compiler -DCMAKE_C_COMPILER=/path/to/C-compiler      If you are building HyPhy under MacOS X, you can specify which version of SDK to use, for example:      cmake -DCMAKE_OSX_SYSROOT=/Developer/SDKs/MacOSX10.9.sdk/ .    Build HyPhy by running  make  with one of the following build targets given below. Note that including the  -j  flag for make (i.e.  make -j  target ) will dramatically speed this step up by taking advantage of multiple processors.  ## make the HYPHYMP executable:\nmake MP\n## Faster:\nmake -j MP\n\n## make the HYPHYMPI executable:\nmake MPI    MP  - build a HyPhy executable ( HYPHYMP ) using  OpenMP  to support symmetric multiprocessing. If  OpenMP  is not installed or not supported by the compiler (e.g. LLVM), the compiled executable will not support multi-threading. You can confirm  case by examining the output from running  cmake . If  openMP  is installed, you should see something similar to the following in the output:  -- Performing Test OpenMP_FLAG_DETECTED\n-- Performing Test OpenMP_FLAG_DETECTED - Success\n-- Try OpenMP CXX flag = [-fopenmp]\n-- Performing Test OpenMP_FLAG_DETECTED\n-- Performing Test OpenMP_FLAG_DETECTED - Success\n-- Found OpenMP: -fopenmp    MPI  - build a HyPhy executable ( HYPHYMPI ) using the message passing interface  MPI  to support parallel execution on distributed systems (clusters). An MPI library (e.g., OpenMPI) must be installed and available in your path. You can check if this is the case by examining the output from running  cmake . If  openMPI  is installed, you should see something similar to the following in the output:       --   Found   MPI_C :   / opt / scyld / openmpi / 1 . 6 . 3 / gnu / lib / libmpi . so ;/ usr / lib64 / libibverbs . so ;/ usr / lib64 / libdat . so ;/ usr / lib64 / librt . so ;/ usr / lib64 / libnsl . so ;/ usr / lib64 / libutil . so ;/ usr / lib64 / libm . so ;/ usr / lib64 / libtorque . so ;/ usr / lib64 / libm . so ;/ usr / lib64 / libnuma . so ;/ usr / lib64 / librt . so ;/ usr / lib64 / libnsl . so ;/ usr / lib64 / libutil . so ;/ usr / lib64 / libm . so \n\n     --   Found   MPI_CXX :   / opt / scyld / openmpi / 1 . 6 . 3 / gnu / lib / libmpi_cxx . so ;/ opt / scyld / openmpi / 1 . 6 . 3 / gnu / lib / libmpi . so ;/ usr / lib64 / libibverbs . so ;/ usr / lib64 / libdat . so ;/ usr / lib64 / librt . so ;/ usr / lib64 / libnsl . so ;/ usr / lib64 / libutil . so ;/ usr / lib64 / libm . so ;/ usr / lib64 / libtorque . so ;/ usr / lib64 / libm . so ;/ usr / lib64 / libnuma . so ;/ usr / lib64 / librt . so ;/ usr / lib64 / libnsl . so ;/ usr / lib64 / libutil . so ;/ usr / lib64 / libm . so       Finally, install HyPhy on your system with the command  make install  HyPhy will install either in its default location  /usr/local/ , or in any custom   /location/of/choice/  provided when configuring  CMake .   HYPHYMP(I)  will be installed at   /location/of/choice/bin  libhyphy_mp.(so/dylib/dll)  will be installed at  /location/of/choice/lib  HyPhy's standard library of scripts/batchfiles will go into  /location/of/choice/lib/hyphy", 
            "title": "Installation"
        }, 
        {
            "location": "/getting-started/", 
            "text": "Using HyPhy\n#\n\n\nThere are four ways to use HyPhy:\n\n\nRun HyPhy on our accompanying Datamonkey webserver\n#\n\n\nThis option is the \neasiest\n, \nsupports most popular analyses\n, and \ndoes not require use of the command line\n. Access Datamonkey \nhere\n, or see this \ndevelopment version of Datamonkey\n for newer methods and a dramatically better user experience.\n\n\nRun HyPhy from the command line\n#\n\n\nThis option is the \nmost flexible\n approach through which you can access \nall available analyses and pipelines\n as well as \ncustomize\n your own HyPhy analyses. Follow \nthese instructions\n for download and installation. \n\n\nRun HyPhy custom analyses without the command line\n#\n\n\nRun a legacy graphical user interface version of HyPhy (no longer developed, but still supporting many popular analyses) Mac OS X or Windows. Follow \nthese instructions\n for download and installation.\n\n\nUse HyPhy for software/pipeline development\n#\n\n\nCompile HyPhy as a library that can be accessed via Python, R, or other language bindings. Follow \nthese instructions\n for download and installation. \n\n\nTypical uses of HyPhy\n#\n\n\nHyPhy ships with a library of \nstandard analyses\n that implement ~100 different methods from start to finish. HyPhy is most commonly used for \ncharacterizing the evolutionary process\n, in particular:\n\n\n\n\nDetecting signatures of selection\n\n\nEstimating evolutionary rates\n\n\nComparing different evolutionary models\n\n\nFitting custom models to sequence alignments\n\n\n\n\nCharacterizing selective pressures\n#\n\n\nHyPhy provides a suite of diverse phylogenetic methodologies for testing specific hypotheses about selection in protein-coding and/or amino-acid multiple sequence alignments. Which method you select will depend on your specific question. Below we recommend several methods for different purposes, linked to more in depth descriptions. Tutorials for using these methods are also available \nhere\n. \n\n\n\n\nNote that you may find it useful to perform pre-processing on your dataset, specifically by screening for recombination breakpoints using our \nGARD\n (\nG\nenetic \nA\nlgorithm for \nR\necombination \nD\netection) method before proceeding to selection analysis.\n\n\n\n\nAre individual sites subject to \npervasive\n (across the whole phylogeny) positive or purifying selection?\n#\n\n\n\n\nFEL\n (\nF\nixed \nE\nffects \nL\nikelihood) is suitable for small-to-medium sized data sets.\n\n\nSLAC\n (\nS\ningle-\nL\nikelihood \nA\nncestor \nC\nounting) is an approximate method with accuracy similar to FEL, but suitable for larger datasets. However, SLAC is not suitable for highly-diverged sequences.\n\n\nFUBAR\n (\nF\nast, \nU\nnconstrained \nB\nayesian \nA\npp\nR\noximation) is suitable for medium-to-large data sets and is expected to have more power than FEL for detecting pervasive selection at sites. \nFUBAR is the preferred approach for inferring pervasive selection.\n\n\n\n\nAre individual sites subject to \nepisodic\n (at a subset of branches) positive or purifying selection?\n#\n\n\n\n\nMEME\n (\nM\nixed \nE\nffects \nM\nodel of \nE\nvolution) tests for episodic selection at individual sites. Note that MEME does not accept \na priori\n branch specifications (this feature is being introduced with \nv2.3-dev\n and later). \nMEME is the preferred approach for detecting positive selection at individual sites.\n\n\n\n\nAre individual branches subject to \nepisodic\n (at a subset of sites) positive or purifying selection?\n#\n\n\n\n\naBSREL\n (\na\ndaptive \nB\nranch-\nS\nite \nR\nandom \nE\nffects \nL\nikelihood) is an improved version of the common \"branch-site\" class of models. aBSREL allows either for \na priori\n specification of branch(es) to test for selection, or can test each lineage for selection in an exploratory fashion. Note that the exploratory approach will sacrifice power. \naBSREL is the preferred approach for detecting positive selection at individual branches.\n\n\n\n\nHas a gene experienced positive selection at any site on a particular branch or set of branches?\n#\n\n\n\n\nBUSTED\n (\nB\nranch-\nS\nite \nU\nnrestricted \nS\ntatistical \nT\nest for \nE\npisodic \nD\niversification) will test for gene-wide selection at pre-specified lineages. This method is particularly useful for relatively small datasets (fewer than 10 taxa) where other methods may not have sufficient power to detect selection. \nThis method is not suitable for identifying specific sites subject to positive seleciton.\n\n\n\n\nHas gene-wide selection pressure been relaxed or intensified along a certain subset of branches?\n#\n\n\n\n\nRELAX\n tests for a relaxation (e.g. where purifying selection has become less stringent) or an intensification (e.g. where purifying selection has become stronger) of selection pressures along a specified set of \"test\" branches. \nThis method is not suitable for detecting positive selection.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/getting-started/#using-hyphy", 
            "text": "There are four ways to use HyPhy:", 
            "title": "Using HyPhy"
        }, 
        {
            "location": "/getting-started/#run-hyphy-on-our-accompanying-datamonkey-webserver", 
            "text": "This option is the  easiest ,  supports most popular analyses , and  does not require use of the command line . Access Datamonkey  here , or see this  development version of Datamonkey  for newer methods and a dramatically better user experience.", 
            "title": "Run HyPhy on our accompanying Datamonkey webserver"
        }, 
        {
            "location": "/getting-started/#run-hyphy-from-the-command-line", 
            "text": "This option is the  most flexible  approach through which you can access  all available analyses and pipelines  as well as  customize  your own HyPhy analyses. Follow  these instructions  for download and installation.", 
            "title": "Run HyPhy from the command line"
        }, 
        {
            "location": "/getting-started/#run-hyphy-custom-analyses-without-the-command-line", 
            "text": "Run a legacy graphical user interface version of HyPhy (no longer developed, but still supporting many popular analyses) Mac OS X or Windows. Follow  these instructions  for download and installation.", 
            "title": "Run HyPhy custom analyses without the command line"
        }, 
        {
            "location": "/getting-started/#use-hyphy-for-softwarepipeline-development", 
            "text": "Compile HyPhy as a library that can be accessed via Python, R, or other language bindings. Follow  these instructions  for download and installation.", 
            "title": "Use HyPhy for software/pipeline development"
        }, 
        {
            "location": "/getting-started/#typical-uses-of-hyphy", 
            "text": "HyPhy ships with a library of  standard analyses  that implement ~100 different methods from start to finish. HyPhy is most commonly used for  characterizing the evolutionary process , in particular:   Detecting signatures of selection  Estimating evolutionary rates  Comparing different evolutionary models  Fitting custom models to sequence alignments", 
            "title": "Typical uses of HyPhy"
        }, 
        {
            "location": "/getting-started/#characterizing-selective-pressures", 
            "text": "HyPhy provides a suite of diverse phylogenetic methodologies for testing specific hypotheses about selection in protein-coding and/or amino-acid multiple sequence alignments. Which method you select will depend on your specific question. Below we recommend several methods for different purposes, linked to more in depth descriptions. Tutorials for using these methods are also available  here .    Note that you may find it useful to perform pre-processing on your dataset, specifically by screening for recombination breakpoints using our  GARD  ( G enetic  A lgorithm for  R ecombination  D etection) method before proceeding to selection analysis.", 
            "title": "Characterizing selective pressures"
        }, 
        {
            "location": "/getting-started/#are-individual-sites-subject-to-pervasive-across-the-whole-phylogeny-positive-or-purifying-selection", 
            "text": "FEL  ( F ixed  E ffects  L ikelihood) is suitable for small-to-medium sized data sets.  SLAC  ( S ingle- L ikelihood  A ncestor  C ounting) is an approximate method with accuracy similar to FEL, but suitable for larger datasets. However, SLAC is not suitable for highly-diverged sequences.  FUBAR  ( F ast,  U nconstrained  B ayesian  A pp R oximation) is suitable for medium-to-large data sets and is expected to have more power than FEL for detecting pervasive selection at sites.  FUBAR is the preferred approach for inferring pervasive selection.", 
            "title": "Are individual sites subject to pervasive (across the whole phylogeny) positive or purifying selection?"
        }, 
        {
            "location": "/getting-started/#are-individual-sites-subject-to-episodic-at-a-subset-of-branches-positive-or-purifying-selection", 
            "text": "MEME  ( M ixed  E ffects  M odel of  E volution) tests for episodic selection at individual sites. Note that MEME does not accept  a priori  branch specifications (this feature is being introduced with  v2.3-dev  and later).  MEME is the preferred approach for detecting positive selection at individual sites.", 
            "title": "Are individual sites subject to episodic (at a subset of branches) positive or purifying selection?"
        }, 
        {
            "location": "/getting-started/#are-individual-branches-subject-to-episodic-at-a-subset-of-sites-positive-or-purifying-selection", 
            "text": "aBSREL  ( a daptive  B ranch- S ite  R andom  E ffects  L ikelihood) is an improved version of the common \"branch-site\" class of models. aBSREL allows either for  a priori  specification of branch(es) to test for selection, or can test each lineage for selection in an exploratory fashion. Note that the exploratory approach will sacrifice power.  aBSREL is the preferred approach for detecting positive selection at individual branches.", 
            "title": "Are individual branches subject to episodic (at a subset of sites) positive or purifying selection?"
        }, 
        {
            "location": "/getting-started/#has-a-gene-experienced-positive-selection-at-any-site-on-a-particular-branch-or-set-of-branches", 
            "text": "BUSTED  ( B ranch- S ite  U nrestricted  S tatistical  T est for  E pisodic  D iversification) will test for gene-wide selection at pre-specified lineages. This method is particularly useful for relatively small datasets (fewer than 10 taxa) where other methods may not have sufficient power to detect selection.  This method is not suitable for identifying specific sites subject to positive seleciton.", 
            "title": "Has a gene experienced positive selection at any site on a particular branch or set of branches?"
        }, 
        {
            "location": "/getting-started/#has-gene-wide-selection-pressure-been-relaxed-or-intensified-along-a-certain-subset-of-branches", 
            "text": "RELAX  tests for a relaxation (e.g. where purifying selection has become less stringent) or an intensification (e.g. where purifying selection has become stronger) of selection pressures along a specified set of \"test\" branches.  This method is not suitable for detecting positive selection.", 
            "title": "Has gene-wide selection pressure been relaxed or intensified along a certain subset of branches?"
        }, 
        {
            "location": "/resources/", 
            "text": "Resources\n#\n\n\n\n\n\n\nTutorials for using standard methods in HyPhy to infer selection ware available \nhere\n. Detailed descriptions of these methods are available \nhere\n.\n\n\n\n\n\n\nCurrent HyPhy selection analyses output JSON-formatted files, whose contents are documented \nhere\n. \n\n\n\n\n\n\nBook chapters and Powerpoints detailing HyPhy usage:\n\n\n\n\nQuantifying Natural Selection in Coding Sequences (2016)\n \n\n\nHyPhy Book: Estimating selection pressures on alignments of\ncoding sequences (2007)\n\n\nIntroduction: Compartmentalization Detection\n \n\n\n\n\n\n\n\n\nGetting help\n\n\n\n\nSee the current \nGithub Issues\n page for posting questions or searching queries from other users.\n\n\nThe retired (as of 2014) user forum is also available for viewing \nhere\n.\n\n\nYou can also tweet us at \n@hyphy_software\n with quick questions.", 
            "title": "Resources"
        }, 
        {
            "location": "/resources/#resources", 
            "text": "Tutorials for using standard methods in HyPhy to infer selection ware available  here . Detailed descriptions of these methods are available  here .    Current HyPhy selection analyses output JSON-formatted files, whose contents are documented  here .     Book chapters and Powerpoints detailing HyPhy usage:   Quantifying Natural Selection in Coding Sequences (2016)    HyPhy Book: Estimating selection pressures on alignments of\ncoding sequences (2007)  Introduction: Compartmentalization Detection       Getting help   See the current  Github Issues  page for posting questions or searching queries from other users.  The retired (as of 2014) user forum is also available for viewing  here .  You can also tweet us at  @hyphy_software  with quick questions.", 
            "title": "Resources"
        }, 
        {
            "location": "/methods/general/", 
            "text": "Overview\n#\n\n\nHyPhy provides a suite of tools for analyzing phylogenetic sequence data, in particular for inferring the strength of selection from sequence data. In addition, HyPhy features a flexible batch language for implementing and customizing discrete state Markov models in a phylogenetic framework.\n\n\n\n\n\nMG94xREV Framework\n#\n\n\nAll methods used to infer selection from coding-sequence data rely, to some extent, on the MG94xREV codon model, a generalized extension of the \nMG94 model\n that allows for a full GTR mutation rate matrix. The MG94xREV \ntransition matrix\n \nQ\n (also known as the \ninstantaneous rate matrix\n), for the substitution from codon \ni\n to codon \nj\n is given by: \n\n\n\n\n\\begin{equation}\nq_{ij} = \\left\\{ \n\\begin{array}{rl}\n\\alpha\\theta_{ij}\\pi_{j},         &\\delta(i,j)=1, AA(i)=AA(j)     \\\\\n\\beta\\theta_{ij}\\pi_{j},          &\\delta(i,j)=1, AA(i)\\neq AA(j) \\\\\n0,                                 &\\delta(i,j)>1                  \\\\\n-\\sum_{k \\neq i}q_{ik},            & i=j\n\\end{array} \\right.\n\\end{equation}\n\n\n\n\nParameters in this matrix include the following:\n\n\n\n\n\n\nThe function \n\\boldsymbol{\\delta(i,j)}\n is an indicator function that equals the number of nucleotide differences between codons \ni\n and \nj\n; for example, \n\\delta(AAA,AAT) = 1\n and \n\\delta(AAA,CCG) = 3\n. Like most other codon models, the MG94xREV model considers only single-nucleotide codon substitutions to be instantaneous. \n\n\n\n\n\n\n\n\n\\boldsymbol{AA(i)}\n refers to the amino-acid encoded by codon \ni\n.\n\n\n\n\n\n\n\n\n\\boldsymbol{\\alpha}\n represents the \nsynonymous substitution rate\n dS, and \n\\boldsymbol{\\beta}\n represents the \nnonsynonymous substitution rate\n dN. Hence, \ndN/dS = \\beta/\\alpha\n. We refer to the \ndN/dS\n ratio as simply \n\\omega\n.\n\n\n\n\n\n\nTogether, the mutation model (\"REV\" component of MG94xREV model) is described by two parameter sets: \n\\boldsymbol{\\Theta}\n, comprised of values \n\\theta_{ij}\n, and \n\\boldsymbol{\\Pi}\n, comprised of values \n\\pi_{j}\n. \n\\Theta\n values are the \nnucleotide mutational biases\n, and \n\\Pi\n are the \nequilibrium nucleotide frequencies\n.\n\n\n\n\n\n\nNot explicitly seen in this model are the \nequilibrium codon frequencies\n, denoted \n\\boldsymbol{\\hat{\\Pi}}\n. These frequencies are estimated using nine positional nucleotide frequencies for the target nucleotides in each codon substitution. Specifically, HyPhy employs the \nCF3x4\n frequency estimator, a corrected version of the common F3x4 estimator (introduced in \nGoldman and Yang 1994\n) which accounts for biases in nucleotide composition induced by stop codons. \n\n\n\n\n\n\nMost methods \n will perform a global MG94xREV fit to optimize branch length and nucleotide substitution parameters before proceeding to hypothesis testing. Several methods (\nFEL\n, \nFUBAR\n, and \nMEME\n) additionally pre-fit a GTR nucleotide model to the data, using the estimated parameters as starting values for the global MG94xREV fit, as a computational speed-up. Resulting branch length and nucleotide substitution parameters are subsequently used as initial parameter values during model fitting for hypothesis testing.\n\n\n\n\n\nSynonymous Rate Variation\n#\n\n\nA key component of HyPhy methods is the inclusion of \nsynonymous rate variation\n. In other words, dS is allowed to vary across sites and/or branches, depending on the specific method. \nThis paper\n provides a detailed analysis demonstrating why incorporating synonymous rate variation into positive selection inference is likely beneficial. Importantly, this consideration of synonymous rate variation stands in contrast to methods implemented in, for example, \nPAML\n where dS is constrained to equal 1.", 
            "title": "General Information"
        }, 
        {
            "location": "/methods/general/#overview", 
            "text": "HyPhy provides a suite of tools for analyzing phylogenetic sequence data, in particular for inferring the strength of selection from sequence data. In addition, HyPhy features a flexible batch language for implementing and customizing discrete state Markov models in a phylogenetic framework.", 
            "title": "Overview"
        }, 
        {
            "location": "/methods/general/#mg94xrev-framework", 
            "text": "All methods used to infer selection from coding-sequence data rely, to some extent, on the MG94xREV codon model, a generalized extension of the  MG94 model  that allows for a full GTR mutation rate matrix. The MG94xREV  transition matrix   Q  (also known as the  instantaneous rate matrix ), for the substitution from codon  i  to codon  j  is given by:    \\begin{equation}\nq_{ij} = \\left\\{ \n\\begin{array}{rl}\n\\alpha\\theta_{ij}\\pi_{j},         &\\delta(i,j)=1, AA(i)=AA(j)     \\\\\n\\beta\\theta_{ij}\\pi_{j},          &\\delta(i,j)=1, AA(i)\\neq AA(j) \\\\\n0,                                 &\\delta(i,j)>1                  \\\\\n-\\sum_{k \\neq i}q_{ik},            & i=j\n\\end{array} \\right.\n\\end{equation}   Parameters in this matrix include the following:    The function  \\boldsymbol{\\delta(i,j)}  is an indicator function that equals the number of nucleotide differences between codons  i  and  j ; for example,  \\delta(AAA,AAT) = 1  and  \\delta(AAA,CCG) = 3 . Like most other codon models, the MG94xREV model considers only single-nucleotide codon substitutions to be instantaneous.      \\boldsymbol{AA(i)}  refers to the amino-acid encoded by codon  i .     \\boldsymbol{\\alpha}  represents the  synonymous substitution rate  dS, and  \\boldsymbol{\\beta}  represents the  nonsynonymous substitution rate  dN. Hence,  dN/dS = \\beta/\\alpha . We refer to the  dN/dS  ratio as simply  \\omega .    Together, the mutation model (\"REV\" component of MG94xREV model) is described by two parameter sets:  \\boldsymbol{\\Theta} , comprised of values  \\theta_{ij} , and  \\boldsymbol{\\Pi} , comprised of values  \\pi_{j} .  \\Theta  values are the  nucleotide mutational biases , and  \\Pi  are the  equilibrium nucleotide frequencies .    Not explicitly seen in this model are the  equilibrium codon frequencies , denoted  \\boldsymbol{\\hat{\\Pi}} . These frequencies are estimated using nine positional nucleotide frequencies for the target nucleotides in each codon substitution. Specifically, HyPhy employs the  CF3x4  frequency estimator, a corrected version of the common F3x4 estimator (introduced in  Goldman and Yang 1994 ) which accounts for biases in nucleotide composition induced by stop codons.     Most methods   will perform a global MG94xREV fit to optimize branch length and nucleotide substitution parameters before proceeding to hypothesis testing. Several methods ( FEL ,  FUBAR , and  MEME ) additionally pre-fit a GTR nucleotide model to the data, using the estimated parameters as starting values for the global MG94xREV fit, as a computational speed-up. Resulting branch length and nucleotide substitution parameters are subsequently used as initial parameter values during model fitting for hypothesis testing.", 
            "title": "MG94xREV Framework"
        }, 
        {
            "location": "/methods/general/#synonymous-rate-variation", 
            "text": "A key component of HyPhy methods is the inclusion of  synonymous rate variation . In other words, dS is allowed to vary across sites and/or branches, depending on the specific method.  This paper  provides a detailed analysis demonstrating why incorporating synonymous rate variation into positive selection inference is likely beneficial. Importantly, this consideration of synonymous rate variation stands in contrast to methods implemented in, for example,  PAML  where dS is constrained to equal 1.", 
            "title": "Synonymous Rate Variation"
        }, 
        {
            "location": "/methods/selection-methods/", 
            "text": "Methods for Inferring Selection Pressure\n#\n\n\nHyPhy distributes a variety of methods for inferring the strength of natural selection in your data using the \ndN/dS\n metric. Here, we provide an overview of each method. For help determining which method best suits your specific needs, follow \nthese guidelines\n.\n\n\naBSREL\n#\n\n\naBSREL (\na\ndaptive \nB\nranch-\nS\nite \nR\nandom \nE\nffects \nL\nikelihood) is an improved version of the commonly-used \"branch-site\" models, which are used to test if positive selection has occurred on a proportion of branches. As such, aBSREL models both site-level and branch-level \n\\omega\n  heterogeneity. aBSREL, however, does not test for selection at specific sites. Instead, aBSREL will test, for each branch (or branch of interest) in the phylogeny, whether a proportion of sites have evolved under positive selection. \n\n\naBSREL differs from other branch-site model implementations by inferring the optimal number of \n\\omega\n  classes for each branch. For example, the earlier HyPhy branch-site approach (BS-REL) assumed three \n\\omega\n  rate classes for each branch and assigned each site, with some probability, to one of these classes. aBSREL, by contrast, acknowledges that different branches may feature more or less complex evolutionary patterns and hence may be better modeled by more or fewer \n\\omega\n classes. Specifically, aBSREL uses AIC\nc\n (small sample AIC) to infer the optimal number of \n\\omega\n rate classes for each branch. \n\n\nAfter aBSREL fits the full adaptive model, the Likelihood Ratio Test is performed at each branch and compares the full model to a null model where branches are not allowed to have rate classes of \n\\omega>1\n. \n\n\naBSREL can be run in two modes:\n\n\n\n\nTest a specific hypothesis by \na priori\n selecting a set of \"foreground\" branches to test for positive selection. \n\n\nPerform an exploratory analysis where all branches are tested for positive selection. In this scenario, p-values at each branch must be corrected for multiple testing (using the Holm-Bonferroni correction). Due to multiple testing, the exploratory approach \nhas much lower power\n compared to the other approach. \n\n\n\n\nIf you use aBSREL in your analysis, please cite the following:\n \nSmith, MD et al. \"Less is more: an adaptive branch-site random effects model for efficient detection of episodic diversifying selection.\" Mol. Biol. Evol. 32, 1342\u20131353 (2015).\n\n\n\n\n\nBUSTED\n#\n\n\nBUSTED (\nB\nranch-\nS\nite \nU\nnrestricted \nS\ntatistical \nT\nest for \nE\npisodic \nD\niversification) provides a gene-wide (\nnot site-specific\n) test for positive selection by asking whether a gene has experienced positive selection at at least one site on at least one branch. When running BUSTED, users can either specify a set of foreground branches on which to test for positive selection (remaining branches are designated \"background\"), or users can test the entire phylogeny for positive selection. In the latter case, the entire tree is effectively treated as foreground, and the test for positive selection considers the entire phylogeny.\n\n\nFor each phylogenetic partition (foreground and background branch sites), BUSTED fits a codon model with three rate classes, constrained as \n\\omega_1 \\leq \\omega_2 \\leq 1 \\leq \\omega_3\n. As in other methods, BUSTED simultaneously estimates the proportion of sites per partition belonging to each \n\\omega\n  class. This model, used as the alternative model in selection testing, is referred to as the \nUnconstrained\n model. BUSTED then tests for positive selection by comparing this model fit to a null model where \n\\omega_3 = 1\n (i.e. disallowing positive selection) on the foreground branches. This null model is also referred to as the \nConstrained\n model. If the null hypothesis is rejected, then there is evidence that at least one site has, at least some of the time, experienced positive selection on the foreground branches. Importantly, a significant result \ndoes not\n mean that the gene evolved under positive selection along the entire foreground.\n\n\nBUSTED additionally calculates \"Evidence Ratios\" (ERs) for each site. The ER gives the likelihood ratio (reported on a log-scale) that the alternative model was a better fit to the data compared to the null model. The ER for each site thus provides \ndescriptive information\n about whether a given site could have evolved under positive selection. The ERs \nshould not\n be interpreted as statistical evidence for positive selection at individual sites (instead, methods like \nMEME\n, \nFEL\n, or \nFUBAR\n should be used for detecting selection at individual sites). \n\n\nFor each site, two ERs are reported: the \nConstrained Model\n ER and the \nOptimized Null\n Model ER. The Constrained Model ER calculates the evidence ratio using model parameters inferred from the Constrained model. By contrast, the Optimized Null model ER re-optimizes parameters inferred using the Constrained model for the given site of interest. These optimized parameter values are then used to calculate the site's ER. Again, while these ERs may be helpful descriptors of selection in the data set, they do not provide statistically valid evidence for positive selection at a site.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \n\n\nIf you use BUSTED in your analysis, please cite the following:\n \nMurrell, B et al. \"Gene-wide identification of episodic selection.\" Mol. Biol. Evol. 32, 1365\u20131371 (2015).\n\n\n\n\n\n\n\n\n\n\n\nFEL\n#\n\n\nFEL (\nF\nixed \nE\nffects \nL\nikelihood) uses a maximum-likelihood (ML) approach to infer nonsynoymous (dN) and synonymous (dS) substitution rates on a per-site basis for a given coding alignment and corresponding phylogeny. This method assumes that the selection pressure for each site is constant along the entire phylogeny. \n\n\nAfter optimizing branch lengths and nucleotide substitution parameters, FEL fits a MG94xREV model to each codon site to infer site-specific nonsynonymous and synonymous (dN and dS, respectively) substitution rates. Hypothesis testing is then conducted on a site-specific basis, using the Likelihood Ratio Test, to ascertain if dN is significantly greater than dS.\n\n\nIf you use FEL in your analysis, please cite the following:\n \nKosakovsky Pond, SL and Frost, SDW. \"Not So Different After All: A Comparison of Methods for Detecting Amino Acid Sites Under Selection.\" Mol. Biol. Evol. 22, 1208--1222 (2005).\n\n\n\n\n\nFUBAR\n#\n\n\nFUBAR (\nF\nast, \nU\nnconstrained \nB\nayesian \nA\npp\nR\noximation) uses a Bayesian approach to infer nonsynoymous (dN) and synonymous (dS) substitution rates on a per-site basis for a given coding alignment and corresponding phylogeny. This method assumes that the selection pressure for each site is constant along the entire phylogeny.\n\n\nAlthough FUBAR produces similar information to FEL, it has several key differences:\n\n\n\n\nFUBAR employs a Bayesian algorithm to infer rates, and therefore it reports evidence for positive selection using \nposterior probabilities\n (which range from 0-1), not p-values. Generally, posterior probabilities \n 0.9 are strongly suggestive of positive selection. \n\n\nFUBAR runs extremely quickly and is well-suited for analyzing large alignments, with hundreds or thousands of sequences. This speed-up results from the novel strategy of employing a pre-specified discrete grid of dN and dS values to be applied across sites. This approach contrasts with the time-consuming FEL strategy of fitting a new MG94xREV model at each site.\n\n\nFUBAR may have more power than FEL, in particular when positive selection is present but relatively weak (i.e. low values of \n\\omega>1\n).\n\n\n\n\nIf you use FUBAR in your analysis, please cite the following:\n \nMurrell, B et al. \"FUBAR: A Fast, Unconstrained Bayesian AppRoximation for inferring selection.\" Mol. Biol. Evol. 30, 1196\u20131205 (2013).\n\n\n\n\n\nGARD\n#\n\n\nGARD (\nG\nenetic \nA\nlgorithm for \nR\necombination \nD\netection) is a method to screen a multiple sequence analysis for the presence of recombination and is extremely useful as a \npre-processing step for selection inference\n. Because recombinant sequences cannot be adequately described with a single phylogenetic history, selection inference on recombinant data often leads to a significant increase in false positives. GARD alleviates this concern by comprehensively screening an alignment for recombination breakpoints and inferring a unique phylogenetic history for each detected recombination block.\n\n\nIf GARD detects recombination in your dataset, it will provide you with an updated \npartitioned\n dataset, where each partition corresponds to a recombination block with its own corresponding phylogeny. This partitioned dataset can then be used as input (instead of your original data) for the selection inference method of interest.\n\n\n\n\n\nIf you use GARD in your analysis, please cite the following:\n \nKosakovsky Pond, SL et al. \"Automated Phylogenetic Detection of Recombination Using a Genetic Algorithm.\" Mol. Biol. Evol. 23, 1891\u20131901 (2006).\n\n\n\n\n\nMEME\n#\n\n\nMEME (\nM\nixed \nE\nffects \nM\nodel of \nE\nvolution) employs a mixed-effects maximum likelihood approach to test the hypothesis that individual sites have been subject to episodic positive or diversifying selection. \nIn other words, MEME aims to detect sites evolving under positive selection under a \nproportion\n of branches.\n\n\nFor each site, MEME infers two \n\\omega\n rate classes and corresponding weights representing the probability that the site evolves under \n\\omega\n rate class, at a given branch. Importantly, to infer \n\\omega\n rates, MEME infers a single \n\\alpha\n (dS) value and two separate \n\\beta\n (dN) values, \n\\beta^-\n and \n\\beta^+\n, which share the same \n\\alpha\n, per site. For both the null and alternative model, MEME enforces the constraint \n\\beta^- \\leq \\alpha\n. The \n\\beta^+\n parameter is therefore the key difference between null and alternative models: In the null model, \n\\beta^+\n is constrained as in the null model: \n\\beta^+ \\leq \\alpha\n, but \n\\beta^+\n is not constrained in the alternative model. Ultimately, positive selection for each site is inferred when \n\\beta^+ > \\alpha\n and shown to be significant using the likelihood ratio test. \n\n\nIf you use MEME in your analysis, please cite the following:\n \nMurrell, B et al. \"Detecting individual sites subject to episodic diversifying selection.\" PLoS Genetics 8, e1002764 (2012).\n\n\n\n\n\nRELAX\n#\n\n\nRELAX is a hypothesis testing framework that asks whether the strength of natural selection has been relaxed or intensified along a specified set of test branches. RELAX is therefore \nnot\n a suitable method for explicitly testing for positive selection. Instead, RELAX is most useful for identifying trends and/or shifts in the stringency of natural selection on a given gene.\n\n\nRELAX requires a specified set of \"test\" branches to compare with a second set of \"reference\" branches (note that all branches do not have to be assigned, but one branch is required the test and reference set each). RELAX begins by fitting a codon model with three \n\\omega\n  classes to the entire phylogeny (null model). RELAX then tests for relaxed/intensified selection by introducing the parameter \nk\n (where \nk \\geq 0\n), serving as the \nselection intensity parameter\n, as an exponent for the inferred \n\\omega\n  values: \n\\omega^k\n. Specifically, RELAX fixes the inferred \n\\omega\n values (all \n\\omega_{<1,2,3>}\n) and infers, for the test branches, a value for \nk\n which modifies the rates to \n\\omega_{<1,2,3>}^k\n (alternative model). RELAX then conducts a Likelihood Ratio Test to compare the alternative and null models. \n\n\nA significant result of \nk\n1 indicates that selection strength has been intensified\n along the test branches, and a significant result of \nk\n1 indicates that selection strength has been relaxed\n along the test branches.\n\n\nIn addition to this pair of null/alternative models, RELAX fits three other models meant as complementary descriptors for the data, but are not suitable for hypothesis testing. These additional models include the following:\n\n\n\n\nPartitioned MG94xREV\n - This model fits a single \n\\omega\n value, i.e. shared for all sites, to each branch partition (reference and test). Here, a total of two \n\\omega\n rates are inferred.\n\n\nPartitioned Descriptive\n - This model, like a more standard branch-site model, fits three \n\\omega\n  classes separately to each branch partition (reference and test, producing a total of six estimated \n\\omega\n rates estimated). The selection intensity parameter \nk\n is not included.\n\n\nGeneral Descriptive\n - This model fits three \n\\omega\n  classes to the full data set, ignoring the specified test and reference partition division (three total \n\\omega\n rates estimated). It subsequently fits a \nk\n parameter at each branch, ultimately tailoring the three \n\\omega\n  class values to this branch. This model may serve as a useful description of how selection intensity fluctuates over the whole tree.\n\n\n\n\nIf you use RELAX in your analysis, please cite the following:\n \nWertheim, JO et al. \"RELAX: detecting relaxed selection in a phylogenetic framework.\" Mol. Biol. Evol. 32, 820\u2013832 (2015).\n\n\n\n\n\nSLAC\n#\n\n\nSLAC (\nS\ningle-\nL\nikelihood \nA\nncestor \nC\nounting) uses a combination of maximum-likelihood (ML) and counting approaches to infer nonsynonymous (dN) and synonymous (dS) substitution rates on a per-site basis for a given coding alignment and corresponding phylogeny. Like FEL, this method assumes that the selection pressure for each site is constant along the entire phylogeny. \n\n\nSLAC begins by optimizing branch lengths and nucleotide substitution parameters under the MG94xREV model. However, rather than using ML to fit site-specific dN and dS parameters, SLAC instead uses ML to infer the most likely ancestral sequence at each node of the phylogeny. SLAC then employs a modified version of the \nSuzuki-Gojobori counting method\n to directly count the total number of nonsynonymous and synonymous changes which have occurred at each site. Significance is ascertained at each site using an extended binomial distribution. Importantly, due to its counting-based approach, SLAC may not be accurate for data sets with high divergence levels.\n\n\nIf you use SLAC in your analysis, please cite the following:\n \nKosakovsky Pond, SL and Frost, SDW. \"Not So Different After All: A Comparison of Methods for Detecting Amino Acid Sites Under Selection.\" Mol. Biol. Evol. 22, 1208--1222 (2005).", 
            "title": "Selection"
        }, 
        {
            "location": "/methods/selection-methods/#methods-for-inferring-selection-pressure", 
            "text": "HyPhy distributes a variety of methods for inferring the strength of natural selection in your data using the  dN/dS  metric. Here, we provide an overview of each method. For help determining which method best suits your specific needs, follow  these guidelines .", 
            "title": "Methods for Inferring Selection Pressure"
        }, 
        {
            "location": "/methods/selection-methods/#absrel", 
            "text": "aBSREL ( a daptive  B ranch- S ite  R andom  E ffects  L ikelihood) is an improved version of the commonly-used \"branch-site\" models, which are used to test if positive selection has occurred on a proportion of branches. As such, aBSREL models both site-level and branch-level  \\omega   heterogeneity. aBSREL, however, does not test for selection at specific sites. Instead, aBSREL will test, for each branch (or branch of interest) in the phylogeny, whether a proportion of sites have evolved under positive selection.   aBSREL differs from other branch-site model implementations by inferring the optimal number of  \\omega   classes for each branch. For example, the earlier HyPhy branch-site approach (BS-REL) assumed three  \\omega   rate classes for each branch and assigned each site, with some probability, to one of these classes. aBSREL, by contrast, acknowledges that different branches may feature more or less complex evolutionary patterns and hence may be better modeled by more or fewer  \\omega  classes. Specifically, aBSREL uses AIC c  (small sample AIC) to infer the optimal number of  \\omega  rate classes for each branch.   After aBSREL fits the full adaptive model, the Likelihood Ratio Test is performed at each branch and compares the full model to a null model where branches are not allowed to have rate classes of  \\omega>1 .   aBSREL can be run in two modes:   Test a specific hypothesis by  a priori  selecting a set of \"foreground\" branches to test for positive selection.   Perform an exploratory analysis where all branches are tested for positive selection. In this scenario, p-values at each branch must be corrected for multiple testing (using the Holm-Bonferroni correction). Due to multiple testing, the exploratory approach  has much lower power  compared to the other approach.    If you use aBSREL in your analysis, please cite the following:   Smith, MD et al. \"Less is more: an adaptive branch-site random effects model for efficient detection of episodic diversifying selection.\" Mol. Biol. Evol. 32, 1342\u20131353 (2015).", 
            "title": "aBSREL"
        }, 
        {
            "location": "/methods/selection-methods/#busted", 
            "text": "BUSTED ( B ranch- S ite  U nrestricted  S tatistical  T est for  E pisodic  D iversification) provides a gene-wide ( not site-specific ) test for positive selection by asking whether a gene has experienced positive selection at at least one site on at least one branch. When running BUSTED, users can either specify a set of foreground branches on which to test for positive selection (remaining branches are designated \"background\"), or users can test the entire phylogeny for positive selection. In the latter case, the entire tree is effectively treated as foreground, and the test for positive selection considers the entire phylogeny.  For each phylogenetic partition (foreground and background branch sites), BUSTED fits a codon model with three rate classes, constrained as  \\omega_1 \\leq \\omega_2 \\leq 1 \\leq \\omega_3 . As in other methods, BUSTED simultaneously estimates the proportion of sites per partition belonging to each  \\omega   class. This model, used as the alternative model in selection testing, is referred to as the  Unconstrained  model. BUSTED then tests for positive selection by comparing this model fit to a null model where  \\omega_3 = 1  (i.e. disallowing positive selection) on the foreground branches. This null model is also referred to as the  Constrained  model. If the null hypothesis is rejected, then there is evidence that at least one site has, at least some of the time, experienced positive selection on the foreground branches. Importantly, a significant result  does not  mean that the gene evolved under positive selection along the entire foreground.  BUSTED additionally calculates \"Evidence Ratios\" (ERs) for each site. The ER gives the likelihood ratio (reported on a log-scale) that the alternative model was a better fit to the data compared to the null model. The ER for each site thus provides  descriptive information  about whether a given site could have evolved under positive selection. The ERs  should not  be interpreted as statistical evidence for positive selection at individual sites (instead, methods like  MEME ,  FEL , or  FUBAR  should be used for detecting selection at individual sites).   For each site, two ERs are reported: the  Constrained Model  ER and the  Optimized Null  Model ER. The Constrained Model ER calculates the evidence ratio using model parameters inferred from the Constrained model. By contrast, the Optimized Null model ER re-optimizes parameters inferred using the Constrained model for the given site of interest. These optimized parameter values are then used to calculate the site's ER. Again, while these ERs may be helpful descriptors of selection in the data set, they do not provide statistically valid evidence for positive selection at a site.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               If you use BUSTED in your analysis, please cite the following:   Murrell, B et al. \"Gene-wide identification of episodic selection.\" Mol. Biol. Evol. 32, 1365\u20131371 (2015).", 
            "title": "BUSTED"
        }, 
        {
            "location": "/methods/selection-methods/#fel", 
            "text": "FEL ( F ixed  E ffects  L ikelihood) uses a maximum-likelihood (ML) approach to infer nonsynoymous (dN) and synonymous (dS) substitution rates on a per-site basis for a given coding alignment and corresponding phylogeny. This method assumes that the selection pressure for each site is constant along the entire phylogeny.   After optimizing branch lengths and nucleotide substitution parameters, FEL fits a MG94xREV model to each codon site to infer site-specific nonsynonymous and synonymous (dN and dS, respectively) substitution rates. Hypothesis testing is then conducted on a site-specific basis, using the Likelihood Ratio Test, to ascertain if dN is significantly greater than dS.  If you use FEL in your analysis, please cite the following:   Kosakovsky Pond, SL and Frost, SDW. \"Not So Different After All: A Comparison of Methods for Detecting Amino Acid Sites Under Selection.\" Mol. Biol. Evol. 22, 1208--1222 (2005).", 
            "title": "FEL"
        }, 
        {
            "location": "/methods/selection-methods/#fubar", 
            "text": "FUBAR ( F ast,  U nconstrained  B ayesian  A pp R oximation) uses a Bayesian approach to infer nonsynoymous (dN) and synonymous (dS) substitution rates on a per-site basis for a given coding alignment and corresponding phylogeny. This method assumes that the selection pressure for each site is constant along the entire phylogeny.  Although FUBAR produces similar information to FEL, it has several key differences:   FUBAR employs a Bayesian algorithm to infer rates, and therefore it reports evidence for positive selection using  posterior probabilities  (which range from 0-1), not p-values. Generally, posterior probabilities   0.9 are strongly suggestive of positive selection.   FUBAR runs extremely quickly and is well-suited for analyzing large alignments, with hundreds or thousands of sequences. This speed-up results from the novel strategy of employing a pre-specified discrete grid of dN and dS values to be applied across sites. This approach contrasts with the time-consuming FEL strategy of fitting a new MG94xREV model at each site.  FUBAR may have more power than FEL, in particular when positive selection is present but relatively weak (i.e. low values of  \\omega>1 ).   If you use FUBAR in your analysis, please cite the following:   Murrell, B et al. \"FUBAR: A Fast, Unconstrained Bayesian AppRoximation for inferring selection.\" Mol. Biol. Evol. 30, 1196\u20131205 (2013).", 
            "title": "FUBAR"
        }, 
        {
            "location": "/methods/selection-methods/#gard", 
            "text": "GARD ( G enetic  A lgorithm for  R ecombination  D etection) is a method to screen a multiple sequence analysis for the presence of recombination and is extremely useful as a  pre-processing step for selection inference . Because recombinant sequences cannot be adequately described with a single phylogenetic history, selection inference on recombinant data often leads to a significant increase in false positives. GARD alleviates this concern by comprehensively screening an alignment for recombination breakpoints and inferring a unique phylogenetic history for each detected recombination block.  If GARD detects recombination in your dataset, it will provide you with an updated  partitioned  dataset, where each partition corresponds to a recombination block with its own corresponding phylogeny. This partitioned dataset can then be used as input (instead of your original data) for the selection inference method of interest.   If you use GARD in your analysis, please cite the following:   Kosakovsky Pond, SL et al. \"Automated Phylogenetic Detection of Recombination Using a Genetic Algorithm.\" Mol. Biol. Evol. 23, 1891\u20131901 (2006).", 
            "title": "GARD"
        }, 
        {
            "location": "/methods/selection-methods/#meme", 
            "text": "MEME ( M ixed  E ffects  M odel of  E volution) employs a mixed-effects maximum likelihood approach to test the hypothesis that individual sites have been subject to episodic positive or diversifying selection. \nIn other words, MEME aims to detect sites evolving under positive selection under a  proportion  of branches.  For each site, MEME infers two  \\omega  rate classes and corresponding weights representing the probability that the site evolves under  \\omega  rate class, at a given branch. Importantly, to infer  \\omega  rates, MEME infers a single  \\alpha  (dS) value and two separate  \\beta  (dN) values,  \\beta^-  and  \\beta^+ , which share the same  \\alpha , per site. For both the null and alternative model, MEME enforces the constraint  \\beta^- \\leq \\alpha . The  \\beta^+  parameter is therefore the key difference between null and alternative models: In the null model,  \\beta^+  is constrained as in the null model:  \\beta^+ \\leq \\alpha , but  \\beta^+  is not constrained in the alternative model. Ultimately, positive selection for each site is inferred when  \\beta^+ > \\alpha  and shown to be significant using the likelihood ratio test.   If you use MEME in your analysis, please cite the following:   Murrell, B et al. \"Detecting individual sites subject to episodic diversifying selection.\" PLoS Genetics 8, e1002764 (2012).", 
            "title": "MEME"
        }, 
        {
            "location": "/methods/selection-methods/#relax", 
            "text": "RELAX is a hypothesis testing framework that asks whether the strength of natural selection has been relaxed or intensified along a specified set of test branches. RELAX is therefore  not  a suitable method for explicitly testing for positive selection. Instead, RELAX is most useful for identifying trends and/or shifts in the stringency of natural selection on a given gene.  RELAX requires a specified set of \"test\" branches to compare with a second set of \"reference\" branches (note that all branches do not have to be assigned, but one branch is required the test and reference set each). RELAX begins by fitting a codon model with three  \\omega   classes to the entire phylogeny (null model). RELAX then tests for relaxed/intensified selection by introducing the parameter  k  (where  k \\geq 0 ), serving as the  selection intensity parameter , as an exponent for the inferred  \\omega   values:  \\omega^k . Specifically, RELAX fixes the inferred  \\omega  values (all  \\omega_{<1,2,3>} ) and infers, for the test branches, a value for  k  which modifies the rates to  \\omega_{<1,2,3>}^k  (alternative model). RELAX then conducts a Likelihood Ratio Test to compare the alternative and null models.   A significant result of  k 1 indicates that selection strength has been intensified  along the test branches, and a significant result of  k 1 indicates that selection strength has been relaxed  along the test branches.  In addition to this pair of null/alternative models, RELAX fits three other models meant as complementary descriptors for the data, but are not suitable for hypothesis testing. These additional models include the following:   Partitioned MG94xREV  - This model fits a single  \\omega  value, i.e. shared for all sites, to each branch partition (reference and test). Here, a total of two  \\omega  rates are inferred.  Partitioned Descriptive  - This model, like a more standard branch-site model, fits three  \\omega   classes separately to each branch partition (reference and test, producing a total of six estimated  \\omega  rates estimated). The selection intensity parameter  k  is not included.  General Descriptive  - This model fits three  \\omega   classes to the full data set, ignoring the specified test and reference partition division (three total  \\omega  rates estimated). It subsequently fits a  k  parameter at each branch, ultimately tailoring the three  \\omega   class values to this branch. This model may serve as a useful description of how selection intensity fluctuates over the whole tree.   If you use RELAX in your analysis, please cite the following:   Wertheim, JO et al. \"RELAX: detecting relaxed selection in a phylogenetic framework.\" Mol. Biol. Evol. 32, 820\u2013832 (2015).", 
            "title": "RELAX"
        }, 
        {
            "location": "/methods/selection-methods/#slac", 
            "text": "SLAC ( S ingle- L ikelihood  A ncestor  C ounting) uses a combination of maximum-likelihood (ML) and counting approaches to infer nonsynonymous (dN) and synonymous (dS) substitution rates on a per-site basis for a given coding alignment and corresponding phylogeny. Like FEL, this method assumes that the selection pressure for each site is constant along the entire phylogeny.   SLAC begins by optimizing branch lengths and nucleotide substitution parameters under the MG94xREV model. However, rather than using ML to fit site-specific dN and dS parameters, SLAC instead uses ML to infer the most likely ancestral sequence at each node of the phylogeny. SLAC then employs a modified version of the  Suzuki-Gojobori counting method  to directly count the total number of nonsynonymous and synonymous changes which have occurred at each site. Significance is ascertained at each site using an extended binomial distribution. Importantly, due to its counting-based approach, SLAC may not be accurate for data sets with high divergence levels.  If you use SLAC in your analysis, please cite the following:   Kosakovsky Pond, SL and Frost, SDW. \"Not So Different After All: A Comparison of Methods for Detecting Amino Acid Sites Under Selection.\" Mol. Biol. Evol. 22, 1208--1222 (2005).", 
            "title": "SLAC"
        }, 
        {
            "location": "/methods/other/evo/", 
            "text": "Analysis list\n#\n\n\n\n\nThis is not a complete list, but the new analyses will be described here.\nOther places to look are \nmanuscript associated analyses\n,\nand the \nGitHub boards\n\n\n\n\nFEL-contrast\n#\n\n\nFor each site in a codon alignment, estimate whether or not dN/dS ratios\ndiffer between sets of branches defined \na priori\n. If the branches are associated with\ndifferent selective environments, this could be used to generate a list of sites that may\nbe evolving at different rates (under different selective pressures) in these environments.\n\n\n\n\nOutputs a list of sites where \ntest\n branches have a statistically detectable difference\n    in dN/dS from \nreference\n branches.\n\n\nCould be used to test for \ndifferential\n selection pressures, for example between\n    host and recipient or individual anatomical compartments in HIV-1, or in between species\n    with different phenotypes/traits.\n\n\n\n\nFurther information", 
            "title": "Evolutionary hypothesis testing"
        }, 
        {
            "location": "/methods/other/evo/#analysis-list", 
            "text": "This is not a complete list, but the new analyses will be described here.\nOther places to look are  manuscript associated analyses ,\nand the  GitHub boards", 
            "title": "Analysis list"
        }, 
        {
            "location": "/methods/other/evo/#fel-contrast", 
            "text": "For each site in a codon alignment, estimate whether or not dN/dS ratios\ndiffer between sets of branches defined  a priori . If the branches are associated with\ndifferent selective environments, this could be used to generate a list of sites that may\nbe evolving at different rates (under different selective pressures) in these environments.   Outputs a list of sites where  test  branches have a statistically detectable difference\n    in dN/dS from  reference  branches.  Could be used to test for  differential  selection pressures, for example between\n    host and recipient or individual anatomical compartments in HIV-1, or in between species\n    with different phenotypes/traits.   Further information", 
            "title": "FEL-contrast"
        }, 
        {
            "location": "/methods/other/fel-contrast/", 
            "text": "FEL-contrast\n#\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHyPhy version required\n\n\n 2.3.4\n\n\n\n\n\n\nParallel support\n\n\nMP and/or MPI\n\n\n\n\n\n\nFile path\n\n\nLIB/TemplateBatchFiles/SelectionAnalyses/FEL-contrast.bf\n\n\n\n\n\n\nStandard analysis menu\n\n\nEvolutionary Hypothesis Testing \n FEL-contrast\n\n\n\n\n\n\n\n\nWhat biological question is the method designed to answer?\n#\n\n\nWhich sites in a gene may be associated with adaptation to a different environment. You need a tree with branches partitioned (a priori) into two sets: reference and test.\n\n\nWhat are the recommended applications?\n#\n\n\nSuppose you have a gene which was sampled from different selective environments.\nThe specific example for which this tool was developed is evolution of HIV in different\nhosts or different compartments (blood vs brain) in the host. Similar situations arise\nwhen the gene is sampled from species living in different environment, eating different food,\nhaving different wavelength eye sensitivity. This division has to be binary, however, so\nthat any branch in the tree is either in the \nreference\n environment, or the \ntest\n environment.\n\n\nFEL-contrast then allows you to examine selective pressures (measured as dN/dS) at each site\nin the gene individually, and test whether or not they are different between environments.\n\n\nArmed with a list of such sites, you could then attempt to explore if evolution at these sites\nis associated with adaptation to the environment.\n\n\nWhat is the statistical procedure and statistical test is used to establish significance for this method?\n#\n\n\nFor each site, three rates are inferred, with other parameters (frequencies, branch lengths) inferred jointly and held at\n\n\n\n\n : synonymous substitution rate\n\n\n \nr\n : non-synonymous substitution rate along \nreference\n branches\n\n\n \np\n : non-synonymous substitution rate along \ntest\n branches\n\n\n\n\nTwo models are compared using a likelihood ratio test\n\n\n\n\n\n\nH\nA\n: \n, \n \nr\n, and \n \nt\n are inferred by maximum likelihood as free parameters\n\n\n\n\n\n\nH\n0\n: The \n \nr\n := \n \nt\n constraint is enforced.\n\n\n\n\n\n\nThe models are nested and differ by one degree of freedom. p-values are computed using the limit \n2\n distribution with one degree of freedom.\n\n\nHow should one interpret positive and negative test results?\n#\n\n\nA significant result at a site means that dN/dS (\n/\nalpha) is \ndifferent\n between the two sets of branches, with either an \nincrease\n or a \ndecrease\n on the test branches \nrelative\n to the reference branches. A significant finding does \nnot\n make any claims about positive (dN/dS \n 1) or negative (dN / dS \n 1), just that dN/dS differ among sets of branches, i.e., a difference need not change the \nmode\n of selection.\n\n\nNegative results do not mean that there is no difference, rather that whatever difference there may be does not rise to the level of statistical significance/\n\n\nRules of thumb for when this method is likely to work well, and when it is not.\n#\n\n\n\n\nGenerally, you need 10 or more branches in each set to be able to have any statistical power.\n\n\nToo little divergence is also likely to severely throttle statistical power.\n\n\n\n\nExample\n#\n\n\nWe will analyze HIV-1 env sequences from a transmission pair: sequences are isolated from the putative source individual and the putative recipient individual from the 2005 study by \nFrost et al\n.\n\n\n\n\n\n\nPartition the tree into the source and recipient (here we include the transmission branch with the source sequences), for example as described \nhere\n. For convenience, \ndownload a NEXUS\n file with the tree already partitioned.\n\n\n\n\n\n\nRun \nHYPHYMP\n or \nHYPHYMPI\n, select \nEvolutionary Hypothesis Testing\n from the menu\nof analyses then select \nUse a FEL method to test which sites in a gene may be associated with adaptation to a different environment.\n Alternatively, you can supply the path of the file as a command line argument, e.g. (by default \n/path/to/hyphylib\n should be \n/usr/local/lib/hyphy\n)\n\n\n$HYPHYMP /path/to/hyphylib/TemplateBatchFiles/SelectionAnalyses/FEL-contrast.bf\n\n\n\n\n\n\nSelect \nUniversal genetic code\n\n\n\n\n\n\nInput the path to the example file downloaded from the link above\n\n\n\n\n\n\nChoose \nSOURCE\n as the test set\n\n\n\n\n\n\nSelect \nYes\n to include synonymous rate variation\n\n\n\n\n\n\nInput \n0.1\n for the default p-value\n\n\n\n\n\n\nThe analysis will now run for a few minutes and output the following results\n\n\n\n\nBranches to use as the test set in the FEL-contrast analysis\n#\n\n\nSelected 24 branches to include in FEL calculations: \n0564_7, 0564_11, 0564_4, Node6, 0564_1, 0564_21, 0564_5, Node11, Node9, Node5, 0564_17, Node4, 0564_13, 0564_15, Node16, 0564_22, 0564_6, Node20, 0564_3, Node19, Node15, Node3, 0564_9, Node2\n\n\nObtaining branch lengths and nucleotide substitution biases under the nucleotide GTR model\n#\n\n\n\n\nLog(L) = -5524.85, AIC-c = 11151.77 (51 estimated parameters)\n\n\n\n\nObtaining the global omega estimate based on relative GTR branch lengths and nucleotide substitution biases\n#\n\n\n\n\nLog(L) = -5436.84, AIC-c = 10991.98 (59 estimated parameters)\n\n\nnon-synonymous/synonymous rate ratio for \nbackground\n =   0.9178\n\n\nnon-synonymous/synonymous rate ratio for \ntest\n =   0.8293\n\n\n\n\nImproving branch lengths, nucleotide substitution biases, and global dN/dS ratios under a full codon model\n#\n\n\n\n\nLog(L) = -5436.29\n\n\nnon-synonymous/synonymous rate ratio for \nbackground\n =   1.1136\n\n\nnon-synonymous/synonymous rate ratio for \ntest\n =   0.7748\n\n\n\n\nFor partition 1 these sites are significant at p \n=0.1\n#\n\n\n\n\n\n\n\n\nCodon\n\n\nalpha\n\n\nbeta-reference\n\n\nbeta-test\n\n\nLRT\n\n\nDifference detected?\n\n\n\n\n\n\n\n\n\n\n4\n\n\n0.000\n\n\n22.380\n\n\n0.000\n\n\n3.390\n\n\nDecr. p = 0.0656\n\n\n\n\n\n\n52\n\n\n0.000\n\n\n20.982\n\n\n0.000\n\n\n3.384\n\n\nDecr. p = 0.0658\n\n\n\n\n\n\n83\n\n\n0.000\n\n\n20.365\n\n\n0.000\n\n\n3.389\n\n\nDecr. p = 0.0656\n\n\n\n\n\n\n118\n\n\n0.000\n\n\n17.179\n\n\n0.000\n\n\n3.404\n\n\nDecr. p = 0.0651\n\n\n\n\n\n\n124\n\n\n0.000\n\n\n23.346\n\n\n0.000\n\n\n3.396\n\n\nDecr. p = 0.0653\n\n\n\n\n\n\n155\n\n\n0.000\n\n\n0.000\n\n\n64.943\n\n\n5.045\n\n\nIncr. p = 0.0247\n\n\n\n\n\n\n187\n\n\n0.000\n\n\n20.934\n\n\n0.000\n\n\n3.577\n\n\nDecr. p = 0.0586\n\n\n\n\n\n\n218\n\n\n0.000\n\n\n20.825\n\n\n0.000\n\n\n3.519\n\n\nDecr. p = 0.0607\n\n\n\n\n\n\n222\n\n\n0.000\n\n\n22.658\n\n\n0.000\n\n\n3.459\n\n\nDecr. p = 0.0629\n\n\n\n\n\n\n224\n\n\n0.000\n\n\n25.874\n\n\n0.000\n\n\n3.681\n\n\nDecr. p = 0.0550\n\n\n\n\n\n\n352\n\n\n0.000\n\n\n19.420\n\n\n0.000\n\n\n3.411\n\n\nDecr. p = 0.0648\n\n\n\n\n\n\n386\n\n\n0.000\n\n\n20.334\n\n\n0.000\n\n\n3.387\n\n\nDecr. p = 0.0657\n\n\n\n\n\n\n417\n\n\n0.000\n\n\n21.316\n\n\n0.000\n\n\n3.383\n\n\nDecr. p = 0.0659\n\n\n\n\n\n\n455\n\n\n0.000\n\n\n22.010\n\n\n0.000\n\n\n3.398\n\n\nDecr. p = 0.0653\n\n\n\n\n\n\n462\n\n\n0.000\n\n\n69.066\n\n\n10.567\n\n\n3.860\n\n\nDecr. p = 0.0494\n\n\n\n\n\n\n466\n\n\n0.000\n\n\n55.142\n\n\n0.000\n\n\n7.562\n\n\nDecr. p = 0.0060\n\n\n\n\n\n\n506\n\n\n0.000\n\n\n33.154\n\n\n0.000\n\n\n3.438\n\n\nDecr. p = 0.0637\n\n\n\n\n\n\n526\n\n\n0.000\n\n\n50.810\n\n\n5.313\n\n\n3.351\n\n\nDecr. p = 0.0672\n\n\n\n\n\n\n533\n\n\n0.000\n\n\n21.489\n\n\n0.000\n\n\n3.485\n\n\nDecr. p = 0.0619\n\n\n\n\n\n\n598\n\n\n0.000\n\n\n18.103\n\n\n0.000\n\n\n3.392\n\n\nDecr. p = 0.0655\n\n\n\n\n\n\n633\n\n\n7.019\n\n\n20.227\n\n\n0.000\n\n\n3.393\n\n\nDecr. p = 0.0655\n\n\n\n\n\n\n748\n\n\n0.000\n\n\n36.773\n\n\n0.000\n\n\n6.388\n\n\nDecr. p = 0.0115\n\n\n\n\n\n\n751\n\n\n0.000\n\n\n18.447\n\n\n0.000\n\n\n3.123\n\n\nDecr. p = 0.0772\n\n\n\n\n\n\n762\n\n\n0.000\n\n\n18.868\n\n\n0.000\n\n\n3.402\n\n\nDecr. p = 0.0651\n\n\n\n\n\n\n788\n\n\n0.000\n\n\n26.735\n\n\n0.000\n\n\n3.937\n\n\nDecr. p = 0.0472\n\n\n\n\n\n\n820\n\n\n0.000\n\n\n56.371\n\n\n0.000\n\n\n9.657\n\n\nDecr. p = 0.0019\n\n\n\n\n\n\n824\n\n\n0.000\n\n\n19.630\n\n\n0.000\n\n\n3.604\n\n\nDecr. p = 0.0576\n\n\n\n\n\n\n\n\n Found \n1\n sites with \nincreased\n dN/dS in the test branches relative to the reference branches and \n26\n sites with \ndecreased\n dN/dS selection at p \n= 0.1\n#", 
            "title": "________"
        }, 
        {
            "location": "/methods/other/fel-contrast/#fel-contrast", 
            "text": "HyPhy version required   2.3.4    Parallel support  MP and/or MPI    File path  LIB/TemplateBatchFiles/SelectionAnalyses/FEL-contrast.bf    Standard analysis menu  Evolutionary Hypothesis Testing   FEL-contrast", 
            "title": "FEL-contrast"
        }, 
        {
            "location": "/methods/other/fel-contrast/#what-biological-question-is-the-method-designed-to-answer", 
            "text": "Which sites in a gene may be associated with adaptation to a different environment. You need a tree with branches partitioned (a priori) into two sets: reference and test.", 
            "title": "What biological question is the method designed to answer?"
        }, 
        {
            "location": "/methods/other/fel-contrast/#what-are-the-recommended-applications", 
            "text": "Suppose you have a gene which was sampled from different selective environments.\nThe specific example for which this tool was developed is evolution of HIV in different\nhosts or different compartments (blood vs brain) in the host. Similar situations arise\nwhen the gene is sampled from species living in different environment, eating different food,\nhaving different wavelength eye sensitivity. This division has to be binary, however, so\nthat any branch in the tree is either in the  reference  environment, or the  test  environment.  FEL-contrast then allows you to examine selective pressures (measured as dN/dS) at each site\nin the gene individually, and test whether or not they are different between environments.  Armed with a list of such sites, you could then attempt to explore if evolution at these sites\nis associated with adaptation to the environment.", 
            "title": "What are the recommended applications?"
        }, 
        {
            "location": "/methods/other/fel-contrast/#what-is-the-statistical-procedure-and-statistical-test-is-used-to-establish-significance-for-this-method", 
            "text": "For each site, three rates are inferred, with other parameters (frequencies, branch lengths) inferred jointly and held at    : synonymous substitution rate    r  : non-synonymous substitution rate along  reference  branches    p  : non-synonymous substitution rate along  test  branches   Two models are compared using a likelihood ratio test    H A :  ,    r , and    t  are inferred by maximum likelihood as free parameters    H 0 : The    r  :=    t  constraint is enforced.    The models are nested and differ by one degree of freedom. p-values are computed using the limit  2  distribution with one degree of freedom.", 
            "title": "What is the statistical procedure and statistical test is used to establish significance for this method?"
        }, 
        {
            "location": "/methods/other/fel-contrast/#how-should-one-interpret-positive-and-negative-test-results", 
            "text": "A significant result at a site means that dN/dS ( / alpha) is  different  between the two sets of branches, with either an  increase  or a  decrease  on the test branches  relative  to the reference branches. A significant finding does  not  make any claims about positive (dN/dS   1) or negative (dN / dS   1), just that dN/dS differ among sets of branches, i.e., a difference need not change the  mode  of selection.  Negative results do not mean that there is no difference, rather that whatever difference there may be does not rise to the level of statistical significance/", 
            "title": "How should one interpret positive and negative test results?"
        }, 
        {
            "location": "/methods/other/fel-contrast/#rules-of-thumb-for-when-this-method-is-likely-to-work-well-and-when-it-is-not", 
            "text": "Generally, you need 10 or more branches in each set to be able to have any statistical power.  Too little divergence is also likely to severely throttle statistical power.", 
            "title": "Rules of thumb for when this method is likely to work well, and when it is not."
        }, 
        {
            "location": "/methods/other/fel-contrast/#example", 
            "text": "We will analyze HIV-1 env sequences from a transmission pair: sequences are isolated from the putative source individual and the putative recipient individual from the 2005 study by  Frost et al .    Partition the tree into the source and recipient (here we include the transmission branch with the source sequences), for example as described  here . For convenience,  download a NEXUS  file with the tree already partitioned.    Run  HYPHYMP  or  HYPHYMPI , select  Evolutionary Hypothesis Testing  from the menu\nof analyses then select  Use a FEL method to test which sites in a gene may be associated with adaptation to a different environment.  Alternatively, you can supply the path of the file as a command line argument, e.g. (by default  /path/to/hyphylib  should be  /usr/local/lib/hyphy )  $HYPHYMP /path/to/hyphylib/TemplateBatchFiles/SelectionAnalyses/FEL-contrast.bf    Select  Universal genetic code    Input the path to the example file downloaded from the link above    Choose  SOURCE  as the test set    Select  Yes  to include synonymous rate variation    Input  0.1  for the default p-value    The analysis will now run for a few minutes and output the following results", 
            "title": "Example"
        }, 
        {
            "location": "/methods/other/fel-contrast/#branches-to-use-as-the-test-set-in-the-fel-contrast-analysis", 
            "text": "Selected 24 branches to include in FEL calculations:  0564_7, 0564_11, 0564_4, Node6, 0564_1, 0564_21, 0564_5, Node11, Node9, Node5, 0564_17, Node4, 0564_13, 0564_15, Node16, 0564_22, 0564_6, Node20, 0564_3, Node19, Node15, Node3, 0564_9, Node2", 
            "title": "Branches to use as the test set in the FEL-contrast analysis"
        }, 
        {
            "location": "/methods/other/fel-contrast/#obtaining-branch-lengths-and-nucleotide-substitution-biases-under-the-nucleotide-gtr-model", 
            "text": "Log(L) = -5524.85, AIC-c = 11151.77 (51 estimated parameters)", 
            "title": "Obtaining branch lengths and nucleotide substitution biases under the nucleotide GTR model"
        }, 
        {
            "location": "/methods/other/fel-contrast/#obtaining-the-global-omega-estimate-based-on-relative-gtr-branch-lengths-and-nucleotide-substitution-biases", 
            "text": "Log(L) = -5436.84, AIC-c = 10991.98 (59 estimated parameters)  non-synonymous/synonymous rate ratio for  background  =   0.9178  non-synonymous/synonymous rate ratio for  test  =   0.8293", 
            "title": "Obtaining the global omega estimate based on relative GTR branch lengths and nucleotide substitution biases"
        }, 
        {
            "location": "/methods/other/fel-contrast/#improving-branch-lengths-nucleotide-substitution-biases-and-global-dnds-ratios-under-a-full-codon-model", 
            "text": "Log(L) = -5436.29  non-synonymous/synonymous rate ratio for  background  =   1.1136  non-synonymous/synonymous rate ratio for  test  =   0.7748", 
            "title": "Improving branch lengths, nucleotide substitution biases, and global dN/dS ratios under a full codon model"
        }, 
        {
            "location": "/methods/other/fel-contrast/#for-partition-1-these-sites-are-significant-at-p-01", 
            "text": "Codon  alpha  beta-reference  beta-test  LRT  Difference detected?      4  0.000  22.380  0.000  3.390  Decr. p = 0.0656    52  0.000  20.982  0.000  3.384  Decr. p = 0.0658    83  0.000  20.365  0.000  3.389  Decr. p = 0.0656    118  0.000  17.179  0.000  3.404  Decr. p = 0.0651    124  0.000  23.346  0.000  3.396  Decr. p = 0.0653    155  0.000  0.000  64.943  5.045  Incr. p = 0.0247    187  0.000  20.934  0.000  3.577  Decr. p = 0.0586    218  0.000  20.825  0.000  3.519  Decr. p = 0.0607    222  0.000  22.658  0.000  3.459  Decr. p = 0.0629    224  0.000  25.874  0.000  3.681  Decr. p = 0.0550    352  0.000  19.420  0.000  3.411  Decr. p = 0.0648    386  0.000  20.334  0.000  3.387  Decr. p = 0.0657    417  0.000  21.316  0.000  3.383  Decr. p = 0.0659    455  0.000  22.010  0.000  3.398  Decr. p = 0.0653    462  0.000  69.066  10.567  3.860  Decr. p = 0.0494    466  0.000  55.142  0.000  7.562  Decr. p = 0.0060    506  0.000  33.154  0.000  3.438  Decr. p = 0.0637    526  0.000  50.810  5.313  3.351  Decr. p = 0.0672    533  0.000  21.489  0.000  3.485  Decr. p = 0.0619    598  0.000  18.103  0.000  3.392  Decr. p = 0.0655    633  7.019  20.227  0.000  3.393  Decr. p = 0.0655    748  0.000  36.773  0.000  6.388  Decr. p = 0.0115    751  0.000  18.447  0.000  3.123  Decr. p = 0.0772    762  0.000  18.868  0.000  3.402  Decr. p = 0.0651    788  0.000  26.735  0.000  3.937  Decr. p = 0.0472    820  0.000  56.371  0.000  9.657  Decr. p = 0.0019    824  0.000  19.630  0.000  3.604  Decr. p = 0.0576", 
            "title": "For partition 1 these sites are significant at p &lt;=0.1"
        }, 
        {
            "location": "/methods/other/fel-contrast/#found-1-sites-with-increased-dnds-in-the-test-branches-relative-to-the-reference-branches-and-26-sites-with-decreased-dnds-selection-at-p-01", 
            "text": "", 
            "title": "Found 1 sites with increased dN/dS in the test branches relative to the reference branches and 26 sites with decreased dN/dS selection at p &lt;= 0.1"
        }, 
        {
            "location": "/tutorials/current-release-tutorial/", 
            "text": "Using HyPhy to detect selection.\n#\n\n\nThese tutorials outline how to prepare data and execute analyses in HyPhy's suite of methods for detecting natural selection in protein-coding alignments. Specifically, this tutorial explains how to use the \ncurrent release\n of HyPhy from the \ncommand line\n. \n\n\nAll analyses described here produce a final output JSON-formatted file which can be uploaded to \nHyPhy Vision\n for exploration. You can obtain a description of JSON contents for all analyses \nhere\n. In addition, each analyses will provide live \nMarkdown-formatted\n status indicators to the console while running. \n\n\nBefore you begin\n#\n\n\n\n\nInstall the current release of HyPhy on your computer, as needed, using \nthese instructions\n.\n\n\nThis tutorial employs example datasets, available for download as a \nzip file\n. Unpack this zip file on your machine for use and \nremember the absolute path to this directory\n. All datasets and output JSON files for this tutorial are in this zip file.\n\n\nThis tutorial assumes you are specifically using the HyPhy executable \nHYPHYMP\n. If you have installed a different executable (e.g. \nHYPHYMPI\n), you may need to alter some commands.\n\n\n\n\n\nPreparing labeled phylogenies\n#\n\n\nSeveral analyses are accept labeled phylogenies to define branch sets for selection testing. Moreover, the method \nRELAX\n \nrequires\n a labeled phylogeny to compare selection pressures. To assist in tree labeling, we recommend using our \nPhylotree Widget\n. Instructions for using this widget are available \nhere\n.\n\n\nPreparing input data for HyPhy\n#\n\n\nAll analyses require an alignment and corresponding phylogeny for analysis. There are options for preparing your data:\n\n\n\n\nPrepare your data in two separate files with the alignment and phylogeny each. Most standard alignemnt formats are accepted (FASTA, phylip, etc.), and the phylogeny should be newick-formatted.\n\n\nPrepare your data in a single file containing a FASTA-formatted alignment, beneath which should be a newick-formatted phylogeny.\n\n\nPrepare your data as a NEXUS file with both a data matrix and tree block. Note that this file type will be necessary for performing a partitioned analysis, where different sites evolve according to different phylogenies (i.e. a recombination-corrected dataset from \nGARD\n.\n\n\n\n\nEach of these choices will trigger a slightly different data-input prompt, as described in the \nGeneral Information\n section below.\n\n\nGeneral Information\n#\n\n\nAll available selection analyses in HyPhy can be accessed by launching HyPhy from the command line by typing \nHYPHYMP\n (or launching \nHYPHYMPI\n in an appropriate MPI environment) and entering \n1\n to reach the \nSelection Analyses\n menu: \n\n\n\nIn this menu, launch your desired analyis by issuing its associated number (i.e. launch FEL by entering \n2\n upon reaching this menu).\n\n\nWithin each analysis, you will see a series of prompts for providing information. All analyses begin with the following prompts:\n\n\n\n\n\n\nChoose Genetic Code\n. Generally, the universal genetic code (\n1\n) should be provided here, unless the dataset of interest uses a different NCBI-defined genetic code. For each option, the corresponding NCBI translation table is indicated.\n\n\n\n\n\n\nSelect a coding sequence alignment file\n. This option prompts for the dataset to analyze. Provide the \nfull path\n to the dataset of interest. \n\n\n\n\nIf you provide a file containing only an alignment, HyPhy will issue a subsequent prompt: \nPlease select a tree file for the data\n. Supply the full path to your newick-formatted phylogeny here.\n\n\nIf you provide a file containing both an alignment and tree, HyPhy will prompt you to confirm that the tree provided should be used: \nA tree was found in the data file:...Would you like to use it (y/n)?\n. Enter \ny\n to use this tree, or enter \nn\n if a different tree is desired. HyPhy will then prompt for this path.\n\n\nIf you provide a NEXUS file, Hyphy will accept the tree(s) as given and will not issue a subsequent prompt.\n\n\n\n\n\n\n\n\nUse BUSTED to test for alignment-wide episodic diversifying selection.\n#\n\n\n\n\nSee \nhere\n for a description of the BUSTED method.\n\n\n\n\nWe will demonstate BUSTED use with an alignment of primate sequences for the KSR2 gene, a kinase suppressor of RAS-2, from \nEnard et al, 2016\n. This dataset is in the file \nksr2.fna\n.\n\n\nLaunch HyPhy from the command line by typing \nHYPHYMP\n. Navigate through the prompt to reach the BUSTED analysis: Enter \n1\n for \"Selection Analyses\", and then \n5\n for \"BUSTED\". Respond to the following prompts:\n\n\n\n\nChoose Genetic Code\n: Enter \n1\n to select the Universal genetic code.\n\n\nSelect a coding sequence alignment file\n: Enter the full path to the example dataset, \n/path/to/tutorial_data/ksr2.fna\n\n\nA tree was found in the data file:...Would you like to use it (y/n)?\n: Enter \ny\n to use the provided tree.\n\n\nChoose the set of branches to test for selection\n: To execute a BUSTED analysis that tests the entire tree for selection, enter option \n1\n for \nAll\n. Alternatively, if you wish to test a subset of branches, enter a different option (2,3,4, or other). Note that any labels present in the provided phylogeny will be listed as options in this menu.\n\n\n\n\nBUSTED will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final BUSTED test results:\n\n\n\nWe therefore find that there is evidence for positive, diversifying selection in this dataset, at P=0.0015.\n\n\nUse aBSREL to find lineages which have experienced episodic diversifying selection.\n#\n\n\n\n\nSee \nhere\n for a description of the aBSREL method.\n\n\n\n\nWe will demonstate aBSREL use with an alignment of HIV-1 envelope protein sequences collected from  epidemiologically-linked donor-recipient transmission pairs, from \nFrost et al, 2005\n. This dataset is in the file \nhiv1_transmission.fna\n.\n\n\nLaunch HyPhy from the command line by typing \nHYPHYMP\n. Navigate through the prompt to reach the aBSREL analysis: Enter \n1\n for \"Selection Analyses\", and then \n6\n for \"aBSREL\". Respond to the following prompts:\n\n\n\n\nChoose Genetic Code\n: Enter \n1\n to select the Universal genetic code.\n\n\nSelect a coding sequence alignment file\n: Enter the full path to the example dataset, \n/path/to/tutorial_data/hiv1_transmission.fna\n\n\nA tree was found in the data file:...Would you like to use it (y/n)?\n: Enter \ny\n to use the provided tree.\n\n\nChoose the set of branches to test for selection\n: To test for selection on each branch of your tree (an \"exploratory\" analysis that may suffer from low power), enter option \n1\n for \nAll\n. Alternatively, if you wish to test for selection only on a subset of branches, enter a different option (2,3,4, or other). Note that any labels present in the provided phylogeny will be listed as options in this menu.\n\n\n\n\naBSREL will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final aBSREL test results (abbreviated output shown here with final result only):\n\n\n\nWe therefore find that there is evidence for episodic diversifying selection in this dataset along three branches, after applying the Bonferroni-Holm procedure to control family-wise error rates.         \n\n\nUse FEL to find sites which have experienced pervasive diversifying selection.\n#\n\n\n\n\nSee \nhere\n for a description of the FEL method.\n\n\n\n\nWe will demonstate FEL use with an alignment of abalone sperm lysin sequences. This dataset is in the file \nlysin.fna\n.\n\n\nLaunch HyPhy from the command line by typing \nHYPHYMP\n. Navigate through the prompt to reach the FEL analysis: Enter \n1\n for \"Selection Analyses\", and then \n2\n for \"FEL\". Respond to the following prompts:\n\n\n\n\nChoose Genetic Code\n: Enter \n1\n to select the Universal genetic code.\n\n\nSelect a coding sequence alignment file\n: Enter the full path to the example dataset, \n/path/to/tutorial_data/lysin.fna\n\n\nA tree was found in the data file:...Would you like to use it (y/n)?\n: Enter \ny\n to use the provided tree.\n\n\nChoose the set of branches to test for selection\n: To perform tests for diversifying selection that consider all branches, enter option \n1\n for \nAll\n. Alternatively, if you wish to test for site-level selection considering only a subset of branches, enter a different option (2,3,4, or other). Note that any labels present in the provided phylogeny will be listed as options in this menu.\n\n\nUse synonymous rate variation? Strongly recommended YES for selection inference.\n: Enter \n1\n to employ synonymous rate variation. If you would like to constrain dS=1 at all sites, for example to calculate evolutionary rate point estimates, enter \n2\n. \n\n\nSelect the p-value threshold to use when testing for selection\n: Provide the desired P-value threshold for calling sites as positively selected. We recommend \n0.1\n for FEL.\n\n\n\n\nFEL will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final FEL test results:\n\n\n\nNote that FEL will formally test for both positive and negative selection at each site. This analysis found 22 sites under pervasive negative selection and 17 sites under pervasive positive selection at our specified threshold of P\n0.1.\n\n\nUse MEME to find sites which have experienced pervasive diversifying selection.\n#\n\n\n\n\nSee \nhere\n for a description of the MEME method.\n\n\n\n\nWe will demonstate MEME use with an alignment of abalone sperm lysin sequences. This dataset is in the file \nlysin.fna\n.\n\n\nLaunch HyPhy from the command line by typing \nHYPHYMP\n. Navigate through the prompt to reach the MEME analysis: Enter \n1\n for \"Selection Analyses\", and then \n1\n for \"MEME\". Respond to the following prompts:\n\n\n\n\nChoose Genetic Code\n: Enter \n1\n to select the Universal genetic code.\n\n\nSelect a coding sequence alignment file\n: Enter the full path to the example dataset, \n/path/to/tutorial_data/h3_trunk.fna\n\n\nA tree was found in the data file:...Would you like to use it (y/n)?\n: Enter \ny\n to use the provided tree.\n\n\nChoose the set of branches to test for selection\n: To perform tests for episodic selection that consider all branches, enter option \n1\n for \nAll\n. Alternatively, if you wish to test for site-level selection considering only a subset of branches, enter a different option (2,3,4, or other). Note that any labels present in the provided phylogeny will be listed as options in this menu.\n\n\nSelect the p-value threshold to use when testing for selection\n: Provide the desired P-value threshold for calling sites as positively selected. We recommend \n0.1\n for MEME.\n\n\n\n\nMEME will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final MEME test results):\n\n\n\nNote that MEME will formally test only for positive, but not negative, selection at each site. This analysis found 30 sites under episodic positive selection at our specified threshold of P\n0.1.\n\n\nUse SLAC to find sites which have experienced pervasive diversifying selection.\n#\n\n\n\n\nSee \nhere\n for a description of the SLAC method.\n\n\n\n\nWe will demonstate SLAC use with an alignment of abalone sperm lysin sequences. This dataset is in the file \nlysin.fna\n.\n\n\nLaunch HyPhy from the command line by typing \nHYPHYMP\n. Navigate through the prompt to reach the SLAC analysis: Enter \n1\n for \"Selection Analyses\", and then \n3\n for \"SLAC\". Respond to the following prompts:\n\n\n\n\nChoose Genetic Code\n: Enter \n1\n to select the Universal genetic code.\n\n\nSelect a coding sequence alignment file\n: Enter the full path to the example dataset, \n/path/to/tutorial_data/h3_trunk.fna\n\n\nA tree was found in the data file:...Would you like to use it (y/n)?\n: Enter \ny\n to use the provided tree.\n\n\nChoose the set of branches to test for selection\n: To perform tests for episodic selection that consider all branches, enter option \n1\n for \nAll\n. Alternatively, if you wish to test for site-level selection considering only a subset of branches, enter a different option (2,3,4, or other). Note that any labels present in the provided phylogeny will be listed as options in this menu.\n\n\nSelect the number of samples used to assess ancestral reconstruction uncertainty\n: This prompt asks how many bootstrap samples to draw for generating confidence intervals. Provide the value \n100\n.\n\n\nSelect the p-value threshold to use when testing for selection\n: Provide the desired P-value threshold for calling sites as positively selected. We recommend \n0.1\n for MEME.\n\n\n\n\nSLAC will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final SLAC test results (abbreviated for visual purposes):\n\n\n\nNote that SLAC will formally test for both positive and negative selection at each site. This analysis found 13 sites under pervasive negative selection and 8 sites under pervasive positive selection at our specified threshold of P\n0.1.\n\n\nUse FUBAR to find sites which have experienced pervasive diversifying selection.\n#\n\n\n\n\nSee \nhere\n for a description of the FUBAR method.\n\n\n\n\nWe will demonstate FUBAR use with an alignment of influenza A H3N2 hemagglutinin sequences subsetted from \nMeyer and Wilke 2015\n to sample sequences only along the trunk. This dataset is in the file \nh3_trunk.fna\n.\n\n\n\n\nChoose Genetic Code\n: Enter \n1\n to select the Universal genetic code.\n\n\nSelect a coding sequence alignment file\n: Enter the full path to the example dataset, \n/path/to/tutorial_data/h3_trunk.fna\n\n\nA tree was found in the data file:...Would you like to use it (y/n)?\n: Enter \ny\n to use the provided tree.\n\n\nNumber of grid points per dimension\n: Press the \nEnter\n key to accept the default of 20.\n\n\nNumber of MCMC chains to run\n: Press the \nEnter\n key to accept the default of 5.\n\n\nThe length of each chain\n: Press the \nEnter\n key to accept the default of 2000000.\n\n\nUse this many samples as burn-in\n:Press the \nEnter\n key to accept the default of 1000000.\n\n\nHow many samples should be drawn from each chain\n: Press the \nEnter\n key to accept the default of 100.\n\n\nThe concentration parameter of the Dirichlet prior\n: Press the \nEnter\n key to accept the default of 0.5.\n\n\n\n\nFUBAR will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final FUBAR test results (abbreviated output shown here with final result only):\n\n\n\nNote that FUBAR will formally test for both positive and negative selection at each site, although it currently only reports positively selected sites to screen. This analysis found 6 sites under pervasive positive selection at a posterior probability \n= 0.9\n\n\nUse RELAX to compare selective pressures on different parts of the tree\n#\n\n\n\n\nSee \nhere\n for a description of the RELAX method.\n\n\n\n\nWe will demonstate RELAX use with an alignment of HIV-1 envelope protein sequences collected from  epidemiologically-linked donor-recipient transmission pairs, from \nFrost et al, 2005\n. This dataset is in the file \nhiv1_transmission_labeled.fna\n.\n\n\nLaunch HyPhy from the command line by typing \nHYPHYMP\n. Navigate through the prompt to reach the RELAX analysis: Enter \n1\n for \"Selection Analyses\", and then \n7\n for \"RELAX\". Respond to the following prompts:\n\n\n\n\nChoose Genetic Code\n: Enter \n1\n to select the Universal genetic code.\n\n\nSelect a coding sequence alignment file\n: Enter the full path to the example dataset, \n/path/to/tutorial_data/hiv1_transmission_labeled.fna\n\n\nA tree was found in the data file:...Would you like to use it (y/n)?\n: Enter \ny\n to use the provided tree.\n\n\nChoose the set of branches to use as the _test_ set\n: Enter \n2\n to select all branches labeled \"test\" as the test set. Note that if your tree contains multiple labels, HyPhy will issue a subsequent prompt asking you to specify the reference set of lineages from these labels.\n\n\nRELAX analysis type\n: Enter \n1\n to run only the RELAX test, and \n2\n to run the RELAX test as well as fit other descriptive models. Here, enter \n2\n.\n\n\n\n\nRELAX will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final RELAX test results (abbreviated output shown here with final result only):\n\n\n\nThis analysis did not detect any evidence of relaxed selection. However, if it had, a significant K\n1 would indicate intensified selection on test lineages, and significant K\n1 would indicate relaxed selection on test lineages.", 
            "title": "Using HyPhy to Detect Selection"
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#using-hyphy-to-detect-selection", 
            "text": "These tutorials outline how to prepare data and execute analyses in HyPhy's suite of methods for detecting natural selection in protein-coding alignments. Specifically, this tutorial explains how to use the  current release  of HyPhy from the  command line .   All analyses described here produce a final output JSON-formatted file which can be uploaded to  HyPhy Vision  for exploration. You can obtain a description of JSON contents for all analyses  here . In addition, each analyses will provide live  Markdown-formatted  status indicators to the console while running.", 
            "title": "Using HyPhy to detect selection."
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#before-you-begin", 
            "text": "Install the current release of HyPhy on your computer, as needed, using  these instructions .  This tutorial employs example datasets, available for download as a  zip file . Unpack this zip file on your machine for use and  remember the absolute path to this directory . All datasets and output JSON files for this tutorial are in this zip file.  This tutorial assumes you are specifically using the HyPhy executable  HYPHYMP . If you have installed a different executable (e.g.  HYPHYMPI ), you may need to alter some commands.", 
            "title": "Before you begin"
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#preparing-labeled-phylogenies", 
            "text": "Several analyses are accept labeled phylogenies to define branch sets for selection testing. Moreover, the method  RELAX   requires  a labeled phylogeny to compare selection pressures. To assist in tree labeling, we recommend using our  Phylotree Widget . Instructions for using this widget are available  here .", 
            "title": "Preparing labeled phylogenies"
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#preparing-input-data-for-hyphy", 
            "text": "All analyses require an alignment and corresponding phylogeny for analysis. There are options for preparing your data:   Prepare your data in two separate files with the alignment and phylogeny each. Most standard alignemnt formats are accepted (FASTA, phylip, etc.), and the phylogeny should be newick-formatted.  Prepare your data in a single file containing a FASTA-formatted alignment, beneath which should be a newick-formatted phylogeny.  Prepare your data as a NEXUS file with both a data matrix and tree block. Note that this file type will be necessary for performing a partitioned analysis, where different sites evolve according to different phylogenies (i.e. a recombination-corrected dataset from  GARD .   Each of these choices will trigger a slightly different data-input prompt, as described in the  General Information  section below.", 
            "title": "Preparing input data for HyPhy"
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#general-information", 
            "text": "All available selection analyses in HyPhy can be accessed by launching HyPhy from the command line by typing  HYPHYMP  (or launching  HYPHYMPI  in an appropriate MPI environment) and entering  1  to reach the  Selection Analyses  menu:   In this menu, launch your desired analyis by issuing its associated number (i.e. launch FEL by entering  2  upon reaching this menu).  Within each analysis, you will see a series of prompts for providing information. All analyses begin with the following prompts:    Choose Genetic Code . Generally, the universal genetic code ( 1 ) should be provided here, unless the dataset of interest uses a different NCBI-defined genetic code. For each option, the corresponding NCBI translation table is indicated.    Select a coding sequence alignment file . This option prompts for the dataset to analyze. Provide the  full path  to the dataset of interest.    If you provide a file containing only an alignment, HyPhy will issue a subsequent prompt:  Please select a tree file for the data . Supply the full path to your newick-formatted phylogeny here.  If you provide a file containing both an alignment and tree, HyPhy will prompt you to confirm that the tree provided should be used:  A tree was found in the data file:...Would you like to use it (y/n)? . Enter  y  to use this tree, or enter  n  if a different tree is desired. HyPhy will then prompt for this path.  If you provide a NEXUS file, Hyphy will accept the tree(s) as given and will not issue a subsequent prompt.", 
            "title": "General Information"
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#use-busted-to-test-for-alignment-wide-episodic-diversifying-selection", 
            "text": "See  here  for a description of the BUSTED method.   We will demonstate BUSTED use with an alignment of primate sequences for the KSR2 gene, a kinase suppressor of RAS-2, from  Enard et al, 2016 . This dataset is in the file  ksr2.fna .  Launch HyPhy from the command line by typing  HYPHYMP . Navigate through the prompt to reach the BUSTED analysis: Enter  1  for \"Selection Analyses\", and then  5  for \"BUSTED\". Respond to the following prompts:   Choose Genetic Code : Enter  1  to select the Universal genetic code.  Select a coding sequence alignment file : Enter the full path to the example dataset,  /path/to/tutorial_data/ksr2.fna  A tree was found in the data file:...Would you like to use it (y/n)? : Enter  y  to use the provided tree.  Choose the set of branches to test for selection : To execute a BUSTED analysis that tests the entire tree for selection, enter option  1  for  All . Alternatively, if you wish to test a subset of branches, enter a different option (2,3,4, or other). Note that any labels present in the provided phylogeny will be listed as options in this menu.   BUSTED will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final BUSTED test results:  We therefore find that there is evidence for positive, diversifying selection in this dataset, at P=0.0015.", 
            "title": "Use BUSTED to test for alignment-wide episodic diversifying selection."
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#use-absrel-to-find-lineages-which-have-experienced-episodic-diversifying-selection", 
            "text": "See  here  for a description of the aBSREL method.   We will demonstate aBSREL use with an alignment of HIV-1 envelope protein sequences collected from  epidemiologically-linked donor-recipient transmission pairs, from  Frost et al, 2005 . This dataset is in the file  hiv1_transmission.fna .  Launch HyPhy from the command line by typing  HYPHYMP . Navigate through the prompt to reach the aBSREL analysis: Enter  1  for \"Selection Analyses\", and then  6  for \"aBSREL\". Respond to the following prompts:   Choose Genetic Code : Enter  1  to select the Universal genetic code.  Select a coding sequence alignment file : Enter the full path to the example dataset,  /path/to/tutorial_data/hiv1_transmission.fna  A tree was found in the data file:...Would you like to use it (y/n)? : Enter  y  to use the provided tree.  Choose the set of branches to test for selection : To test for selection on each branch of your tree (an \"exploratory\" analysis that may suffer from low power), enter option  1  for  All . Alternatively, if you wish to test for selection only on a subset of branches, enter a different option (2,3,4, or other). Note that any labels present in the provided phylogeny will be listed as options in this menu.   aBSREL will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final aBSREL test results (abbreviated output shown here with final result only):  We therefore find that there is evidence for episodic diversifying selection in this dataset along three branches, after applying the Bonferroni-Holm procedure to control family-wise error rates.", 
            "title": "Use aBSREL to find lineages which have experienced episodic diversifying selection."
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#use-fel-to-find-sites-which-have-experienced-pervasive-diversifying-selection", 
            "text": "See  here  for a description of the FEL method.   We will demonstate FEL use with an alignment of abalone sperm lysin sequences. This dataset is in the file  lysin.fna .  Launch HyPhy from the command line by typing  HYPHYMP . Navigate through the prompt to reach the FEL analysis: Enter  1  for \"Selection Analyses\", and then  2  for \"FEL\". Respond to the following prompts:   Choose Genetic Code : Enter  1  to select the Universal genetic code.  Select a coding sequence alignment file : Enter the full path to the example dataset,  /path/to/tutorial_data/lysin.fna  A tree was found in the data file:...Would you like to use it (y/n)? : Enter  y  to use the provided tree.  Choose the set of branches to test for selection : To perform tests for diversifying selection that consider all branches, enter option  1  for  All . Alternatively, if you wish to test for site-level selection considering only a subset of branches, enter a different option (2,3,4, or other). Note that any labels present in the provided phylogeny will be listed as options in this menu.  Use synonymous rate variation? Strongly recommended YES for selection inference. : Enter  1  to employ synonymous rate variation. If you would like to constrain dS=1 at all sites, for example to calculate evolutionary rate point estimates, enter  2 .   Select the p-value threshold to use when testing for selection : Provide the desired P-value threshold for calling sites as positively selected. We recommend  0.1  for FEL.   FEL will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final FEL test results:  Note that FEL will formally test for both positive and negative selection at each site. This analysis found 22 sites under pervasive negative selection and 17 sites under pervasive positive selection at our specified threshold of P 0.1.", 
            "title": "Use FEL to find sites which have experienced pervasive diversifying selection."
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#use-meme-to-find-sites-which-have-experienced-pervasive-diversifying-selection", 
            "text": "See  here  for a description of the MEME method.   We will demonstate MEME use with an alignment of abalone sperm lysin sequences. This dataset is in the file  lysin.fna .  Launch HyPhy from the command line by typing  HYPHYMP . Navigate through the prompt to reach the MEME analysis: Enter  1  for \"Selection Analyses\", and then  1  for \"MEME\". Respond to the following prompts:   Choose Genetic Code : Enter  1  to select the Universal genetic code.  Select a coding sequence alignment file : Enter the full path to the example dataset,  /path/to/tutorial_data/h3_trunk.fna  A tree was found in the data file:...Would you like to use it (y/n)? : Enter  y  to use the provided tree.  Choose the set of branches to test for selection : To perform tests for episodic selection that consider all branches, enter option  1  for  All . Alternatively, if you wish to test for site-level selection considering only a subset of branches, enter a different option (2,3,4, or other). Note that any labels present in the provided phylogeny will be listed as options in this menu.  Select the p-value threshold to use when testing for selection : Provide the desired P-value threshold for calling sites as positively selected. We recommend  0.1  for MEME.   MEME will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final MEME test results):  Note that MEME will formally test only for positive, but not negative, selection at each site. This analysis found 30 sites under episodic positive selection at our specified threshold of P 0.1.", 
            "title": "Use MEME to find sites which have experienced pervasive diversifying selection."
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#use-slac-to-find-sites-which-have-experienced-pervasive-diversifying-selection", 
            "text": "See  here  for a description of the SLAC method.   We will demonstate SLAC use with an alignment of abalone sperm lysin sequences. This dataset is in the file  lysin.fna .  Launch HyPhy from the command line by typing  HYPHYMP . Navigate through the prompt to reach the SLAC analysis: Enter  1  for \"Selection Analyses\", and then  3  for \"SLAC\". Respond to the following prompts:   Choose Genetic Code : Enter  1  to select the Universal genetic code.  Select a coding sequence alignment file : Enter the full path to the example dataset,  /path/to/tutorial_data/h3_trunk.fna  A tree was found in the data file:...Would you like to use it (y/n)? : Enter  y  to use the provided tree.  Choose the set of branches to test for selection : To perform tests for episodic selection that consider all branches, enter option  1  for  All . Alternatively, if you wish to test for site-level selection considering only a subset of branches, enter a different option (2,3,4, or other). Note that any labels present in the provided phylogeny will be listed as options in this menu.  Select the number of samples used to assess ancestral reconstruction uncertainty : This prompt asks how many bootstrap samples to draw for generating confidence intervals. Provide the value  100 .  Select the p-value threshold to use when testing for selection : Provide the desired P-value threshold for calling sites as positively selected. We recommend  0.1  for MEME.   SLAC will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final SLAC test results (abbreviated for visual purposes):  Note that SLAC will formally test for both positive and negative selection at each site. This analysis found 13 sites under pervasive negative selection and 8 sites under pervasive positive selection at our specified threshold of P 0.1.", 
            "title": "Use SLAC to find sites which have experienced pervasive diversifying selection."
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#use-fubar-to-find-sites-which-have-experienced-pervasive-diversifying-selection", 
            "text": "See  here  for a description of the FUBAR method.   We will demonstate FUBAR use with an alignment of influenza A H3N2 hemagglutinin sequences subsetted from  Meyer and Wilke 2015  to sample sequences only along the trunk. This dataset is in the file  h3_trunk.fna .   Choose Genetic Code : Enter  1  to select the Universal genetic code.  Select a coding sequence alignment file : Enter the full path to the example dataset,  /path/to/tutorial_data/h3_trunk.fna  A tree was found in the data file:...Would you like to use it (y/n)? : Enter  y  to use the provided tree.  Number of grid points per dimension : Press the  Enter  key to accept the default of 20.  Number of MCMC chains to run : Press the  Enter  key to accept the default of 5.  The length of each chain : Press the  Enter  key to accept the default of 2000000.  Use this many samples as burn-in :Press the  Enter  key to accept the default of 1000000.  How many samples should be drawn from each chain : Press the  Enter  key to accept the default of 100.  The concentration parameter of the Dirichlet prior : Press the  Enter  key to accept the default of 0.5.   FUBAR will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final FUBAR test results (abbreviated output shown here with final result only):  Note that FUBAR will formally test for both positive and negative selection at each site, although it currently only reports positively selected sites to screen. This analysis found 6 sites under pervasive positive selection at a posterior probability  = 0.9", 
            "title": "Use FUBAR to find sites which have experienced pervasive diversifying selection."
        }, 
        {
            "location": "/tutorials/current-release-tutorial/#use-relax-to-compare-selective-pressures-on-different-parts-of-the-tree", 
            "text": "See  here  for a description of the RELAX method.   We will demonstate RELAX use with an alignment of HIV-1 envelope protein sequences collected from  epidemiologically-linked donor-recipient transmission pairs, from  Frost et al, 2005 . This dataset is in the file  hiv1_transmission_labeled.fna .  Launch HyPhy from the command line by typing  HYPHYMP . Navigate through the prompt to reach the RELAX analysis: Enter  1  for \"Selection Analyses\", and then  7  for \"RELAX\". Respond to the following prompts:   Choose Genetic Code : Enter  1  to select the Universal genetic code.  Select a coding sequence alignment file : Enter the full path to the example dataset,  /path/to/tutorial_data/hiv1_transmission_labeled.fna  A tree was found in the data file:...Would you like to use it (y/n)? : Enter  y  to use the provided tree.  Choose the set of branches to use as the _test_ set : Enter  2  to select all branches labeled \"test\" as the test set. Note that if your tree contains multiple labels, HyPhy will issue a subsequent prompt asking you to specify the reference set of lineages from these labels.  RELAX analysis type : Enter  1  to run only the RELAX test, and  2  to run the RELAX test as well as fit other descriptive models. Here, enter  2 .   RELAX will now run to completion and print markdown-formatted status indicators to screen, indicating the progression of model fits and concluding with the final RELAX test results (abbreviated output shown here with final result only):  This analysis did not detect any evidence of relaxed selection. However, if it had, a significant K 1 would indicate intensified selection on test lineages, and significant K 1 would indicate relaxed selection on test lineages.", 
            "title": "Use RELAX to compare selective pressures on different parts of the tree"
        }, 
        {
            "location": "/tutorials/phylotree/", 
            "text": "Labeling phylogenies is critical for branch-level analyses such as RELAX and BUSTED. These instructions detail the most basic usage of the \nphylotree.js\n widget's branch labeling functionality. \n\n\n\n\nUpload your phylogeny.\n\n\nClick the \nNewick\n dropdown menu at the top left of the site and choose your newick-formatted phylogeny to upload. Once uploaded, the phylogeny will load in the widget for labeling and/or manipulation.\n\n\n\n\n\n\nIn the text box next to the \nTag\n dropdown menu, create all of your labels \nbefore selecting/highlighting any branches\n. \n\n\nBy default, the first label will always be named \nForeground\n. This can be renamed with \nTag-\nRename selection set\n as desired. Be sure to click \nSave\n when finished renaming!\n\n\nTo additional more labels, click \nTag-\nNew selection set\n. Each new selection set will be named, by default, \nnew_selection_name\n. You can change this name now by directly typing the new name into the text field next to the \nTag\n button. Again, click \nSave\n when finished renaming.\n\n\n\n\n\n\n\n\nAfter all labels have been created, they will be visible in differently-colored text under the \nTag\n dropdown menu. To select branches for a label, follow these steps:\n\n\n\n\nClick the label of interest in the \nTag\n dropdown menu. The name of your chosen label will now be shown in the text box to the right of \nTag\n. \n\n\nHighlight and select any branches for this label. \n\n\nWhen finished, navigate back to \nTag\n to select the next label of interest, and select branches accordingly. Proceed until all selections are complete.\n\n\n\n\n\n\n\n\nExport your labeled phylogeny by clicking the \nNewick\n dropdown menu and then \nExport\n. A text box with your labeled newick tree will appear. Copy and paste this newick tree as needed.", 
            "title": "Labeling branches with phylotree"
        }
    ]
}